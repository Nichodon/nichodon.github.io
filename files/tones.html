<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tones Test</title>
   </head>

    <body>
    <p>Try pressing the keys with audio on! The key mapping is very similar to FL Studio.</p>
    </body>

    <script>
    (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.TONES = {})));
}(this, (function (exports) { 'use strict';

    try {
        exports.Context = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        alert("Your browser doesn't support the Web Audio API; audio functionality will be impaired.");
        console.warn("The browser does not support the Web Audio API; audio functionality will be impaired.");
        // TODO: Add popup?
    }

    function chainNodes(nodes) {
        for (let i = 0; i < nodes.length - 1; i++) {
            nodes[i].connect(nodes[i + 1]);
        }
    }

    function removeNodesTimeout(nodes, timeout) {
        return setTimeoutAudioCtx(() => {
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].disconnect();
            }
        }, timeout);
    }

    const masterEntryNode = exports.Context.createGain();
    const masterGainNode = exports.Context.createGain();
    const masterAnalyzerNode = exports.Context.createAnalyser();

    const voidNode = exports.Context.createChannelMerger();
    const voidGainNode = exports.Context.createGain();
    voidGainNode.gain.setValueAtTime(0, 0);

    chainNodes([
        masterEntryNode,
        masterGainNode,
        exports.Context.destination
    ]);

    masterGainNode.connect(masterAnalyzerNode);

    chainNodes([
        voidNode,
        voidGainNode,
        exports.Context.destination
    ]);

    function setMasterGain(gain) {
        masterGainNode.gain = gain;
    }

    let previousVolume;

    function mute() {
        previousVolume = masterGainNode.gain;
        setMasterGain(0);
    }

    function unmute() {
        setMasterGain(previousVolume);
    }

    function contextTime() {
        return exports.Context.currentTime;
    }

    class ContextTimeout {
        constructor(node, time) {
            this.node = node;
            this.time = time;
        }

        ended() {
            return exports.Context.currentTime < this.time;
        }

        cancel() {
            this.node.onended = (x => null);
            this.node.stop();
        }
    }

    function setTimeoutAudioCtx(func, time_delta) {
        let timingNode = exports.Context.createOscillator();
        let curr = exports.Context.currentTime;

        timingNode.start(curr + time_delta);
        timingNode.stop(curr + time_delta);
        timingNode.onended = func;

        timingNode.connect(exports.Context.destination);

        return new ContextTimeout(timingNode, curr + time_delta);
    }

    function setTimeoutAbsoluteAudioCtx(func, audioCtxTime) {
        let timingNode = exports.Context.createOscillator();

        timingNode.start(audioCtxTime);
        timingNode.stop(audioCtxTime);
        timingNode.onended = func;

        timingNode.connect(exports.Context.destination);

        return new ContextTimeout(timingNode, audioCtxTime);
    }

    class Instrument {
        constructor(destinationNode = masterEntryNode) {
            this.panNode = exports.Context.createStereoPanner();
            this.gainNode = exports.Context.createGain();
            this.analyzerNode = exports.Context.createAnalyser();
            this.entryNode = exports.Context.createGain();
            this.destinationNode = destinationNode;

            chainNodes([
                this.entryNode,
                this.gainNode,
                this.panNode,
                destinationNode
            ]);

            this.panNode.connect(this.analyzerNode);

            this.panNode.pan.setValueAtTime(0, 0);

            this.previousVolume = null;
        }

        set volume(gain) {
            this.gainNode.gain = gain;
        }

        get volume() {
            return this.gainNode.gain;
        }

        mute() {
            this.previousVolume = this.volume;
            this.setVolume(0);
        }

        unmute() {
            this.setVolume(this.volume);
        }
    }

    class EnvelopeControlPoint {
        constructor(x, y) {
            if (Array.isArray(x)) {
                this.x = x[0];
                this.y = x[1];
            } else if (y !== undefined) {
                this.x = x;
                this.y = y;
            } else {
                this.x = x.x;
                this.y = x.y;
            }
        }
    }


    // Horizontal functions / constructors
    const EnvelopeHorizontal = {
        offset_current_time: function (x) {
            return x + contextTime();
        },
        offset_by_time: (delta => (function (x) {
            return x + contextTime() + delta;
        })),
        offset_by_absolute_time: (delta => (x => x + delta))
    };

    const EnvelopeHorizontalInverse = {
        offset_current_time: function (x) {
            return x - contextTime();
        },
        offset_by_time: (delta => (function (x) {
            return x - contextTime() - delta;
        })),
        offset_by_absolute_time: (delta => (x => x - delta))
    };

    // Vertical functions / constructors
    const EnvelopeVertical = {
        vertical_idempotent: (x => x),
        vertical_exp: (x => (Math.exp(x) - 1) / Math.exp(2)),
        vertical_exp_by: (exponent => (x => (Math.exp(x) - 1) / Math.exp(exponent))),
    };

    const EnvelopeVerticalInverse = {
        vertical_idempotent: (x => x),
        vertical_exp: (y => Math.log(y * Math.exp(2) + 1)),
        vertical_exp_by: (exponent => (y => Math.log(y * Math.exp(exponent) + 1)))
    };

    // Sample frequency functions / constructors
    const EnvelopeSamples = {
        sample_default: (x => 50),
        sample_by_amount: (samples => (x => samples)),
        smart_sample:  (x => parseInt(5 * x.length() + 5)),
        smart_sample_prec: (prec => (x => prec * x.length()))
    };

    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    class EnvelopeSegment {
        constructor(p1i, p2i, inter_y) {
            p1i = new EnvelopeControlPoint(p1i);
            p2i = new EnvelopeControlPoint(p2i);

            if (p1i === p2i) {
                throw new Error("Points cannot be the same.");
            }

            let p1, p2;

            if (p2i.x < p1i.x) {
                p1 = p2i;
                p2 = p1i;
            } else {
                p1 = p1i;
                p2 = p2i;
            }


            this.p1 = p1;
            this.p2 = p2;

            if (isNumber(inter_y) && ((p1.y < inter_y && inter_y < p2.y) || (p2.y < inter_y && inter_y < p1.y))) {
                this.inter_y = inter_y;
            } else {
                if (isNumber(inter_y)) {
                    throw new Error("Intermediate y value must be well between y values of the endpoints.");
                }
                this.inter_y = (p1.y + p2.y) / 2;
            }
        }

        minX() {
            return this.p1.x;
        }

        minY() {
            return Math.min(this.p1.y, this.p2.y);
        }

        maxX() {
            return this.p2.x;
        }

        maxY() {
            return Math.max(this.p1.y, this.p2.y);
        }

        length() {
            return this.maxX() - this.minX();
        }

        sample(samples = 50, v_apply = EnvelopeVertical.vertical_idempotent) {
            let array = new Float32Array(samples);

            samples -= 1;

            let delta_v = this.p1.y - this.p2.y;

            if (Math.abs(this.inter_y - (this.p1.y + this.p2.y) / 2) < Math.abs(delta_v) / 200 || delta_v === 0) {
                // The segment is pretty linear, so calculate as such

                let minX = this.minX(), maxX = this.maxX(), startY = this.p1.y, endY = this.p2.y;
                let x_delta = maxX - minX;
                let y_delta = endY - startY;
                let x_jump = x_delta / samples;

                for (let i = minX, j = 0; j <= samples; i += x_jump, j++) {
                    array[j] = v_apply((i - minX) / x_delta * y_delta + startY);
                }
            } else {
                // Exponential calculation

                let minX = this.minX(), maxX = this.maxX();
                let x_delta = maxX - minX;
                let x_jump = x_delta / samples;

                let a1 = this.p1.x, a2 = this.p1.y, b2 = this.inter_y, c1 = this.p2.x, c2 = this.p2.y;
                let k = (c1 - a1) / 2;

                let q = Math.pow((c2 - b2) / (b2 - a2), 1 / k);
                let p = (a2 - c2) / (Math.pow(q, a1) - Math.pow(q, c1));
                let s = a2 - p * Math.pow(q, a1);

                for (let i = minX, j = 0; j <= samples; i += x_jump, j++) {
                    array[j] = v_apply(p * Math.pow(q, i) + s);
                }
            }

            return array;
        }

        apply(audioParam, samples = 50, h_apply = EnvelopeHorizontal.offset_current_time, v_apply = EnvelopeVertical.vertical_idempotent) {
            audioParam.setValueCurveAtTime(this.sample(samples, v_apply),
                h_apply(this.minX()),
                h_apply(this.maxX()) - h_apply(this.minX()));
        }
    }


    class Envelope {
        constructor(segments) {

            if (!Array.isArray(segments)) {
                throw new Error("Array of segments must be passed to Envelope constructor.");
            }
            if (segments.length < 1) {
                throw new Error("Not enough segments passed to Envelope constructor.");
            }

            this.segments = [];

            for (let i = 0; i < segments.length; i++) {
                if (i !== 0) {
                    let prevMax = segments[i - 1].maxX();
                    let currMin = segments[i].minX();
                    if (prevMax > currMin) {
                        throw new Error("Discontinuous segments at indices " + String(i - 1) + ", " + String(i));
                    } else if (prevMax < currMin) {
                        this.segments.push(new EnvelopeSegment(segments[i - 1].p2, segments[i].p1));
                    }
                }
                this.segments.push(segments[i]);
            }
        }

        minX() {
            return this.segments[0].minX();
        }

        maxX() {
            return this.segments[this.segments.length - 1].maxX();
        }

        minY() {
            return Math.min(...this.segments.apply(x => x.p1.y), ...this.segments.apply(x => x.p2.y));
        }

        maxY() {
            return Math.max(...this.segments.apply(x => x.p1.y), ...this.segments.apply(x => x.p2.y));
        }

        addSegment(segment) {
            let segMinX = segment.minX();
            let maxX = this.maxX();

            if (segMinX === maxX) {
                this.segments.push(segment);
            } else if (segMinX > maxX) {
                this.segments.push(new EnvelopeSegment(this.segments[this.segments.length - 1].p2, segment.p1));
            } else {
                throw new Error("Discontinuous segment.");
            }
        }

        apply(audioParam, h_apply = EnvelopeHorizontal.offset_current_time,
              v_apply = EnvelopeVertical.vertical_idempotent,
              samplesPerSegment = EnvelopeSamples.smart_sample) {
            this.segments.forEach(x => x.apply(audioParam, samplesPerSegment(x), h_apply, v_apply));
        }
    }

    // Terminology

    // 0 -> C-1, 1 -> C#-1, etc., like MIDI in scientific pitch notation
    // Black notes are named as a sharp by default
    // Sharp -> #, Double sharp -> ##, Flat -> b, Double flat -> bb


    const octave_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function mod(n, m) {
        return ((n % m) + m) % m;
    }

    function noteToName(note) {
        return octave_names[mod(note, 12)] + String(parseInt(note / 12) - 1);
    }

    function isNumber$1(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    const letter_nums = {
        "C": 0,
        "D": 2,
        "E": 4,
        "F": 5,
        "G": 7,
        "A": 9,
        "B": 11
    };

    const accidental_offsets = {
        "#": 1,
        "##": 2,
        "b": -1,
        "bb": -2
    };

    function nameToNote(name) {
        //                letter   accidental  -?  number
        let groups = /^([ABCDEFG])(#|##|B|BB)?(-)?([0-9]+)$/.exec(name.toUpperCase().trim());

        try {
            return letter_nums[groups[1]] +
                (groups[2] ? accidental_offsets[groups[2]] : 0) +
                (groups[3] ? -12 : 12) * (parseInt(groups[4])) + 12;
        } catch (e) {
            throw new Error("Invalid value.");
        }
    }

    const augmented_names = ["A", "AUG", "AUGMENTED"];
    const diminished_names = ["D", "DIM", "DIMIN", "DIMINISHED"];
    const perfect_names = ["P", "PERF", "PERFECT"];

    function getIntervalQuality(desc) {
        desc = desc.trim();
        if (desc[0] === "m" || desc[0] === "M") {
            let desc_upper = desc.toUpperCase();
            if (desc_upper.includes("MIN")) {
                return "min";
            } else if (desc_upper.includes("MAJ")) {
                return "maj";
            } else if (desc[0] === "m" && desc.length === 1) {
                return "min";
            } else if (desc[0] === "M" && desc.length === 1) {
                return "maj";
            } else {
                return null;
            }
        }
        let desc_upper = desc.toUpperCase();
        if (augmented_names.includes(desc_upper)) {
            return "aug";
        }
        if (diminished_names.includes(desc_upper)) {
            return "dim";
        }
        if (perfect_names.includes(desc_upper)) {
            return "perf";
        }
        return null;
    }

    function getIntervalSize(ord) {
        switch (ord) {
            case "1":
            case "one":
            case "first":
            case "1st":
            case "unison":
                return 1;
            case "2":
            case "two":
            case "second":
            case "2nd":
                return 2;
            case "3":
            case "three":
            case "third":
            case "3rd":
                return 3;
            case "four":
            case "fourth":
                return 4;
            case "five":
            case "fifth":
                return 5;
            case "six":
            case "sixth":
                return 6;
            case "seven":
            case "seventh":
                return 7;
            case "eight":
            case "eighth":
            case "octave":
                return 8;
            case "nine":
            case "ninth":
                return 9;
            case "ten":
            case "tenth":
                return 10;
            case "eleven":
            case "eleventh":
                return 11;
            case "twelve":
            case "twelfth":
                return 12;
            case "thirteen":
            case "thirteenth":
                return 13;
            case "fourteen":
            case "fourteenth":
                return 14;
            case "fifteen":
            case "fifteenth":
                return 15;
            case "sixteen":
            case "sixteenth":
                return 16;
            case "seventeen":
            case "seventeenth":
                return 17;
            case "eighteen":
            case "eighteenth":
                return 18;
            case "nineteen":
            case "nineteenth":
                return 19;
            case "twenty":
            case "twentieth":
                return 20;
        }
        let groups = /^([0-9]+)(th|)?$/.exec(ord);
        if (groups) {
            return parseInt(groups[1]);
        }
        return null;
    }

    function nameToInterval(name) {
        name = name.trim();
        let upper_name = name.toUpperCase();
        if (upper_name === "TT" || upper_name === "tritone") {
            return KeyboardIntervals.tritone;
        }
        if (upper_name === "unison") {
            return KeyboardIntervals.unison;
        }
        if (upper_name === "octave") {
            return KeyboardIntervals.octave;
        }
        let groups = /^([A-Za-z]+)\s*([A-Za-z0-9]+)$/.exec(name);

        if (!groups) {
            throw new Error("Invalid interval.");
        }

        let quality = getIntervalQuality(groups[1]);
        let value = getIntervalSize(groups[2]);

        if (!isNumber$1(value) || !quality || !value) {
            throw new Error("Invalid interval.");
        }

        let m_value = value % 7;
        let s_value = parseInt(value / 7);

        if ([4, 5, 1].includes(value % 7)) { // fourth, fifth, (unison, octave)
            value = s_value * 12;

            switch (m_value) {
                case 4:
                    value += 5;
                    break;
                case 5:
                    value += 7;
                    break;
                case 1:
                default:
            }

            switch (quality) {
                case "dim":
                    return new KeyboardInterval(value - 1);
                case "aug":
                    return new KeyboardInterval(value + 1);
                case "perf":
                    return new KeyboardInterval(value);
                default:
                case "min":
                case "maj":
                    throw new Error("Invalid interval.");
            }
        } else {
            value = s_value * 12;

            switch (m_value) {
                case 0: // seventh
                    value += 11;
                    break;
                case 2: // second
                    value += 2;
                    break;
                case 3: // third
                    value += 4;
                    break;
                case 6: // fourth
                    value += 9;
                    break;
            }

            switch (quality) {
                case "dim":
                    return new KeyboardInterval(value - 2);
                case "aug":
                    return new KeyboardInterval(value + 1);
                case "min":
                    return new KeyboardInterval(value - 1);
                case "maj":
                    return new KeyboardInterval(value);
                default:
                case "perf":
                    throw new Error("Invalid interval.");
            }
        }
    }

    function intervalToName(interval_size) {
        let s_value = interval_size % 12;
        let m_value = parseInt(interval_size / 12);

        let prefix;
        let v_value;

        switch (s_value) {
            case 0:
                prefix = "P";
                v_value = 1;
                break;
            case 1:
                prefix = "m";
                v_value = 2;
                break;
            case 2:
                prefix = "M";
                v_value = 2;
                break;
            case 3:
                prefix = "m";
                v_value = 3;
                break;
            case 4:
                prefix = "M";
                v_value = 3;
                break;
            case 5:
                prefix = "P";
                v_value = 4;
                break;
            case 6:
                prefix = "A";
                v_value = 4;
                break;
            case 7:
                prefix = "P";
                v_value = 5;
                break;
            case 8:
                prefix = "m";
                v_value = 6;
                break;
            case 9:
                prefix = "M";
                v_value = 6;
                break;
            case 10:
                prefix = "m";
                v_value = 7;
                break;
            case 11:
                prefix = "M";
                v_value = 7;
                break;
        }

        let value = m_value * 7 + v_value;

        return prefix + String(value);
    }

    const KeyboardIntervals = {
        unison: 0,
        minor_second: 1,
        major_second: 2,
        minor_third: 3,
        major_third: 4,
        perfect_fourth: 5,
        tritone: 6,
        perfect_fifth: 7,
        minor_sixth: 8,
        major_sixth: 9,
        minor_seventh: 10,
        major_seventh: 11,
        octave: 12
    };

    function _isKeyboardNoteInstance(note) {
        return (note instanceof KeyboardNote);
    }

    function _isKeyboardIntervalInstance(interval) {
        return (interval instanceof KeyboardInterval);
    }

    class KeyboardNote {
        constructor(note) {
            if (isNumber$1(note)) {
                this.value = note;
            } else if (_isKeyboardNoteInstance(note)) {
                this.value = note.value;
            } else {
                this.value = nameToNote(note);
            }
        }

        subtract(note) {
            if (_isKeyboardNoteInstance(note) || isNumber$1(note)) {
                return new KeyboardInterval(this.value - new KeyboardNote(note).value);
            } else if (_isKeyboardIntervalInstance(note)) {
                let interval = note;
                return new KeyboardNote(this.value - interval.value);
            }
        }

        add(interval) {
            return new KeyboardNote(this.value + interval.value);
        }

        name() {
            return noteToName(this.value);
        }

        twelveTETFrequency() {
            return Math.pow(2, (this.value - 69) / 12) * 440;
        }
    }

    function makeNote(...args) {
        return new KeyboardNote(...args);
    }

    class KeyboardInterval {
        constructor(arg1, arg2) {
            if (isNumber$1(arg1) && arg2 === undefined) {
                this.value = arg1;
            } else if (arg2 !== undefined) {
                this.value = new KeyboardNote(arg2).subtract(new KeyboardNote(arg1)).value;
            } else if (_isKeyboardIntervalInstance(arg1)) {
                this.value = arg1.value;
            } else if (typeof arg1 === "string") {
                this.value = nameToInterval(arg1).value;
            }
        }

        add(interval) {
            return new KeyboardInterval(this.value + (new KeyboardInterval(interval)).value);
        }

        subtract(interval) {
            return new KeyboardInterval(this.value - (new KeyboardInterval(interval)).value);
        }

        negate() {
            return new KeyboardInterval(-this.value)
        }

        twelveTETCents() {
            return this.value * 100;
        }

        name() {
            return intervalToName(this.value);
        }
    }

    function makeInterval(...args) {
        return new KeyboardInterval(...args);
    }

    for (let key in KeyboardIntervals) {
        KeyboardIntervals[key] = new KeyboardInterval(KeyboardIntervals[key]);
    }

    Object.freeze(KeyboardIntervals);

    const KeyboardNotes = {};

    for (let i = 12; i < 128; i++) { // C0 to G9, notes for easy access
        let note = new KeyboardNote(i);

        KeyboardNotes[note.name().replace("#", "s")] = note;
    }

    class KeyboardMapping {
        constructor(dict, func) { // Key pathway: (keypress / keyup) -> dict -> func call (KeyboardNote, bool pressed)
            this.keydict = dict;
            this.func = func;
            this.enabled = false;
            this.keyPress = (evt => {
                try {
                    this.func(this.keydict[evt.key], true);
                } catch (e) {
                    // Key that's not in the mapping, ok
                }
            });
            this.keyUp = (evt => {
                try {
                    this.func(this.keydict[evt.key], false);
                } catch (e) {
                    // Key that's not in the mapping, ok
                }
            });
        }

        enable() {
            if (!this.enabled) {
                document.addEventListener("keypress", this.keyPress);
                document.addEventListener("keyup", this.keyUp);
                this.enabled = true;
            }
        }

        disable() {
            if (this.enabled) {
                document.removeEventListener("keypress", this.keyPress);
                document.removeEventListener("keyup", this.keyUp);
                this.enabled = false;
            }
        }

        dictApply(func) {
            for (let key in this.keydict) {
                this.keydict[key] = func(this.keydict[key]);
            }
        }

        transform(key) {
            return this.keydict[key];
        }

        virtualPress(key) {
            this.func(this.keydict[key], true);
        }

        virtualRelease(key) {
            this.func(this.keydict[key], false);
        }
    }

    let N = KeyboardNotes;

    let _DefaultKeyboardMapping = {
        "z" : N.C3,
        "s" : N.Cs3,
        "x" : N.D3,
        "d" : N.Ds3,
        "c" : N.E3,
        "v" : N.F3,
        "g" : N.Fs3,
        "b" : N.G3,
        "h" : N.Gs3,
        "n" : N.A3,
        "j" : N.As3,
        "m" : N.B3,
        "," : N.C4,
        "l" : N.Cs4,
        "." : N.D4,
        ";" : N.Ds4,
        "/" : N.E4,
        "q" : N.C4,
        "2" : N.Cs4,
        "w" : N.D4,
        "3" : N.Ds4,
        "e" : N.E4,
        "r" : N.F4,
        "5" : N.Fs4,
        "t" : N.G4,
        "6" : N.Gs4,
        "y" : N.A4,
        "7" : N.As4,
        "u" : N.B4,
        "i" : N.C5,
        "9" : N.Cs5,
        "o" : N.D5,
        "0" : N.Ds5,
        "p" : N.E5,
        "[" : N.F5,
        "+" : N.Fs5,
        "]" : N.G5
    };

    function getDefaultKeyboardDict() {
        return Object.assign({}, _DefaultKeyboardMapping);
    }

    class KeyboardInstrument extends Instrument {
        constructor(destinationNode = masterEntryNode) {
            super(destinationNode);


            this.keyboard = {};
            for (let i = 0; i < 128; i++) {
                this.keyboard[i] = false;
            }
        }

        play(note) {
            if (!this.keyboard[note.value]) {
                this.keyboard[note.value] = true;
                this.onplay(note);
            }
        }

        release(note) {
            if (this.keyboard[note.value]) {
                this.keyboard[note.value] = false;
                this.onrelease(note);
            }
        }

        releaseAll(notes) {
            for (let i = 0; i < 128; i++) {
                release(i);
            }
        }
    }

    class SimpleInstrument extends KeyboardInstrument {
        constructor(dict, destinationNode = masterEntryNode) {
            super(destinationNode);

            this.oscillators = {};
            for (let i = 0; i < 128; i++) {
                this.oscillators[i] = null;
            }

            let a = new EnvelopeSegment([0,0], [0.01,1]);
            let b = new EnvelopeSegment(a.p2, [1, 0.2], 0.4);

            this.attackenvelope = new Envelope([a,b]);
            this.decaylength = 0.1;

            this.createDecayEnvelope = (gain_value) => {
                return new Envelope([new EnvelopeSegment([0, gain_value], [this.decaylength, 0])]);
            };

            this.mapping = new KeyboardMapping(dict, (note, pressing) => {
                if (!note) return;
                if (pressing) {
                    this.play(note);
                } else {
                    this.release(note);
                }
            });
        }

        onplay(note) {
            console.log(note.name(), "play");
            let tone = exports.Context.createOscillator();
            let tone_gain = exports.Context.createGain();

            chainNodes([
                tone,
                tone_gain,
                this.entryNode]);

            tone.type = 'square';
            tone.frequency.value = note.twelveTETFrequency();
            tone_gain.gain.setValueAtTime(0, 0);
            tone.start();

            this.attackenvelope.apply(tone_gain.gain,
                EnvelopeHorizontal.offset_current_time,
                EnvelopeVertical.vertical_exp);

            this.oscillators[note.value] = {tone: tone, tone_gain: tone_gain};
        }

        onrelease(note) {
            console.log(note.name(), "release");
            let group = this.oscillators[note.value];

            group.tone_gain.gain.cancelScheduledValues(0);
            this.createDecayEnvelope(
                EnvelopeVerticalInverse.vertical_exp(group.tone_gain.gain.value)
                // We invert the value because it was transformed by EnvelopeVertical.vertical_exp
            ).apply(group.tone_gain.gain,
                EnvelopeHorizontal.offset_current_time,
                EnvelopeVertical.vertical_exp);

            this.oscillators[note.value] = null;
            let toneGain = group.tone_gain;
            let tone = group.tone;
            removeNodesTimeout([toneGain, tone], this.decaylength + 0.1);
        }

        get keyboardPlayEnabled() {
            return this.mapping.enabled;
        }

        enableKeyboardPlay() {
            this.mapping.enable();
        }

        disableKeyboardPlay() {
            this.mapping.disable();
        }
    }

    exports.Instrument = Instrument;
    exports.masterEntryNode = masterEntryNode;
    exports.masterGainNode = masterGainNode;
    exports.masterAnalyzerNode = masterAnalyzerNode;
    exports.setMasterGain = setMasterGain;
    exports.masterMute = mute;
    exports.masterUnmute = unmute;
    exports.chainNodes = chainNodes;
    exports.contextTime = contextTime;
    exports.setTimeout = setTimeoutAudioCtx;
    exports.setTimeoutAbsolute = setTimeoutAbsoluteAudioCtx;
    exports.voidNode = voidNode;
    exports.ContextTimeout = ContextTimeout;
    exports.removeNodesTimeout = removeNodesTimeout;
    exports.Envelope = Envelope;
    exports.EnvelopeSegment = EnvelopeSegment;
    exports.EnvelopeControlPoint = EnvelopeControlPoint;
    exports.EnvelopeHorizontal = EnvelopeHorizontal;
    exports.EnvelopeHorizontalInverse = EnvelopeHorizontalInverse;
    exports.EnvelopeSamples = EnvelopeSamples;
    exports.EnvelopeVertical = EnvelopeVertical;
    exports.EnvelopeVerticalInverse = EnvelopeVerticalInverse;
    exports.noteToName = noteToName;
    exports.nameToNote = nameToNote;
    exports.KeyboardNote = KeyboardNote;
    exports.KeyboardInterval = KeyboardInterval;
    exports.KeyboardIntervals = KeyboardIntervals;
    exports.KeyboardNotes = KeyboardNotes;
    exports.makeNote = makeNote;
    exports.makeInterval = makeInterval;
    exports.KeyboardMapping = KeyboardMapping;
    exports.getDefaultKeyboardDict = getDefaultKeyboardDict;
    exports.SimpleInstrument = SimpleInstrument;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

    </script>
    
    <script>
    let lowpass_filter = TONES.Context.createBiquadFilter();

lowpass_filter.type = "lowpass";
lowpass_filter.frequency.setValueAtTime(2000, 0);

lowpass_filter.connect(TONES.masterEntryNode);

let instrument = new TONES.SimpleInstrument(TONES.getDefaultKeyboardDict(), lowpass_filter);

instrument.enableKeyboardPlay();
    </script>
<body>

</body>
</html>
