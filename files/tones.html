<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tones Test</title>
   </head>

    <body>
    <p>Try pressing the keys with audio on! The key mapping is very similar to FL Studio.</p>
    <p>Unison</p>
    <input type="number" min="1" max="16" id="unison_input" value="8" step="1">
    <p>Detune</p>
    <input type="range" min="0" max="2000" value="200" id="detune_input">
    <p>Blend</p>
    <input type="range" min="0", max="1000" value="500" id="blend_input">
    <p>Waveform</p>
    <input type="radio" id="sine" name="waveform">
    <label for="sine">Sine</label>
    <input type="radio" id="square" name="waveform" checked>
    <label for="square">Square</label>
    <input type="radio" id="sawtooth" name="waveform">
    <label for="sawtooth">Sawtooth</label>
    <input type="radio" id="triangle" name="waveform">
    <label for="triangle">Triangle</label>
    <p>Temperament File (.scl):</p>
    <input type="file" id="scala_file_input" multiple>
    <p>Base Note:</p>
    <input type="text" id="base_note_input" value="A4">
    <p>Base Frequency:</p>
    <input type="number" id="base_frequency_input" value="440">
    <p>Lowpass Filter Value:</p>
    <input type="range" id="lowpass_input" value="1100" min="500" max="1442">
    <p>Attack</p>
    <input type="range" id="attack_input" value="50" min="1" max="500">
    <p>Decay</p>
    <input type="range" id="decay_input" value="400" min="1" max="700">
    <p>Sustain Value</p>
    <input type="range" id="sustain_input" value="20" min="1" max="100">
    <p>Release</p>
    <input type="range" id="release_input" value="55" min="1" max="700">
    </body>
    
    <script>
        (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.TONES = {})));
}(this, (function (exports) { 'use strict';

    try {
        exports.Context = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        alert("Your browser doesn't support the Web Audio API; audio functionality will be impaired.");
        console.warn("The browser does not support the Web Audio API; audio functionality will be impaired.");
        // TODO: Add popup?
    }

    function chainNodes(nodes) {
        for (let i = 0; i < nodes.length - 1; i++) {
            nodes[i].connect(nodes[i + 1]);
        }
    }

    function removeNodesTimeout(nodes, timeout) {
        return setTimeoutAudioCtx(() => {
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].disconnect();
            }
        }, timeout);
    }

    const masterEntryNode = exports.Context.createGain();
    const masterGainNode = exports.Context.createGain();
    const masterAnalyzerNode = exports.Context.createAnalyser();

    const voidNode = exports.Context.createChannelMerger();
    const voidGainNode = exports.Context.createGain();
    voidGainNode.gain.setValueAtTime(0, 0);

    chainNodes([
        masterEntryNode,
        masterGainNode,
        exports.Context.destination
    ]);

    masterGainNode.connect(masterAnalyzerNode);

    chainNodes([
        voidNode,
        voidGainNode,
        exports.Context.destination
    ]);

    function setMasterGain(gain) {
        masterGainNode.gain = gain;
    }

    let previousVolume;

    function mute() {
        previousVolume = masterGainNode.gain;
        setMasterGain(0);
    }

    function unmute() {
        setMasterGain(previousVolume);
    }

    function contextTime() {
        return exports.Context.currentTime;
    }

    class ContextTimeout {
        constructor(node, time) {
            this.node = node;
            this.time = time;
        }

        ended() {
            return exports.Context.currentTime < this.time;
        }

        cancel() {
            this.node.onended = (x => null);
            this.node.stop();
        }
    }

    function setTimeoutAudioCtx(func, time_delta) {
        let timingNode = exports.Context.createOscillator();
        let curr = exports.Context.currentTime;

        timingNode.start(curr + time_delta);
        timingNode.stop(curr + time_delta);
        timingNode.onended = func;

        timingNode.connect(exports.Context.destination);

        return new ContextTimeout(timingNode, curr + time_delta);
    }

    function setTimeoutAbsoluteAudioCtx(func, audioCtxTime) {
        let timingNode = exports.Context.createOscillator();

        timingNode.start(audioCtxTime);
        timingNode.stop(audioCtxTime);
        timingNode.onended = func;

        timingNode.connect(exports.Context.destination);

        return new ContextTimeout(timingNode, audioCtxTime);
    }

    class Instrument {
        constructor() {
            this.panNode = exports.Context.createStereoPanner();
            this.gainNode = exports.Context.createGain();
            this.analyzerNode = exports.Context.createAnalyser();
            this.entryNode = exports.Context.createGain();

            chainNodes([
                this.entryNode,
                this.gainNode,
                this.panNode
            ]);

            this.panNode.connect(this.analyzerNode);

            this.panNode.pan.setValueAtTime(0, 0);

            this.previousVolume = null;
        }

        set volume(gain) {
            this.gainNode.gain = gain;
        }

        setVolume(volume) {
            this.volume = volume;
        }

        get volume() {
            return this.gainNode.gain;
        }

        mute() {
            this.previousVolume = this.volume;
            this.setVolume(0);
        }

        unmute() {
            this.setVolume(this.volume);
        }

        connect(node) {
            this.panNode.connect(node);
        }

        disconnect() {
            this.panNode.disconnect();
        }
    }

    class EnvelopeControlPoint {
        constructor(x, y) {
            if (Array.isArray(x)) {
                this.x = x[0];
                this.y = x[1];
            } else if (y !== undefined) {
                this.x = x;
                this.y = y;
            } else {
                this.x = x.x;
                this.y = x.y;
            }
        }
    }

    // TODO: Allow 0 attack length, etc.


    // Horizontal functions / constructors
    const EnvelopeHorizontal = {
        offset_current_time: function (x) {
            return x + contextTime();
        },
        offset_by_time: (delta => (function (x) {
            return x + contextTime() + delta;
        })),
        offset_by_absolute_time: (delta => (x => x + delta))
    };

    const EnvelopeHorizontalInverse = {
        offset_current_time: function (x) {
            return x - contextTime();
        },
        offset_by_time: (delta => (function (x) {
            return x - contextTime() - delta;
        })),
        offset_by_absolute_time: (delta => (x => x - delta))
    };

    // Vertical functions / constructors
    const EnvelopeVertical = {
        vertical_idempotent: (x => x),
        vertical_exp: (x => (Math.exp(x) - 1) / Math.exp(2)),
        vertical_exp_by: (exponent => (x => (Math.exp(x) - 1) / Math.exp(exponent))),
    };

    const EnvelopeVerticalInverse = {
        vertical_idempotent: (x => x),
        vertical_exp: (y => Math.log(y * Math.exp(2) + 1)),
        vertical_exp_by: (exponent => (y => Math.log(y * Math.exp(exponent) + 1)))
    };

    // Sample frequency functions / constructors
    const EnvelopeSamples = {
        sample_default: (x => 50),
        sample_by_amount: (samples => (x => samples)),
        smart_sample:  (x => parseInt(5 * x.length() + 5)),
        smart_sample_prec: (prec => (x => prec * x.length()))
    };

    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    class EnvelopeSegment {
        constructor(p1i, p2i, inter_y) {
            p1i = new EnvelopeControlPoint(p1i);
            p2i = new EnvelopeControlPoint(p2i);

            if (p1i === p2i) {
                throw new Error("Points cannot be the same.");
            }

            let p1, p2;

            if (p2i.x < p1i.x) {
                p1 = p2i;
                p2 = p1i;
            } else {
                p1 = p1i;
                p2 = p2i;
            }


            this.p1 = p1;
            this.p2 = p2;

            if (isNumber(inter_y) && ((p1.y < inter_y && inter_y < p2.y) || (p2.y < inter_y && inter_y < p1.y))) {
                this.inter_y = inter_y;
            } else {
                if (isNumber(inter_y)) {
                    throw new Error("Intermediate y value must be well between y values of the endpoints.");
                }
                this.inter_y = (p1.y + p2.y) / 2;
            }
        }

        minX() {
            return this.p1.x;
        }

        minY() {
            return Math.min(this.p1.y, this.p2.y);
        }

        maxX() {
            return this.p2.x;
        }

        maxY() {
            return Math.max(this.p1.y, this.p2.y);
        }

        length() {
            return this.maxX() - this.minX();
        }

        sample(samples = 50, v_apply = EnvelopeVertical.vertical_idempotent) {
            let array = new Float32Array(samples);

            samples -= 1;

            let delta_v = this.p1.y - this.p2.y;

            if (Math.abs(this.inter_y - (this.p1.y + this.p2.y) / 2) < Math.abs(delta_v) / 200 || delta_v === 0) {
                // The segment is pretty linear, so calculate as such

                let minX = this.minX(), maxX = this.maxX(), startY = this.p1.y, endY = this.p2.y;
                let x_delta = maxX - minX;
                let y_delta = endY - startY;
                let x_jump = x_delta / samples;

                for (let i = minX, j = 0; j <= samples; i += x_jump, j++) {
                    array[j] = v_apply((i - minX) / x_delta * y_delta + startY);
                }
            } else {
                // Exponential calculation

                let minX = this.minX(), maxX = this.maxX();
                let x_delta = maxX - minX;
                let x_jump = x_delta / samples;

                let a1 = this.p1.x, a2 = this.p1.y, b2 = this.inter_y, c1 = this.p2.x, c2 = this.p2.y;
                let k = (c1 - a1) / 2;

                let q = Math.pow((c2 - b2) / (b2 - a2), 1 / k);
                let p = (a2 - c2) / (Math.pow(q, a1) - Math.pow(q, c1));
                let s = a2 - p * Math.pow(q, a1);

                for (let i = minX, j = 0; j <= samples; i += x_jump, j++) {
                    array[j] = v_apply(p * Math.pow(q, i) + s);
                }
            }

            return array;
        }

        apply(audioParam, samples = 50, h_apply = EnvelopeHorizontal.offset_current_time, v_apply = EnvelopeVertical.vertical_idempotent) {
            if (this.p1.x === this.p2.x) {
                audioParam.setValueAtTime(Math.max(v_apply(this.p1.y, this.p2.y), h_apply(this.p1.x)));
                return;
            }

            audioParam.setValueCurveAtTime(this.sample(samples, v_apply),
                h_apply(this.minX()),
                h_apply(this.maxX()) - h_apply(this.minX()));
        }
    }


    class Envelope {
        constructor(segments) {

            if (!Array.isArray(segments)) {
                throw new Error("Array of segments must be passed to Envelope constructor.");
            }
            if (segments.length < 1) {
                throw new Error("Not enough segments passed to Envelope constructor.");
            }

            this.segments = [];

            for (let i = 0; i < segments.length; i++) {
                if (i !== 0) {
                    let prevMax = segments[i - 1].maxX();
                    let currMin = segments[i].minX();
                    if (prevMax > currMin) {
                        throw new Error("Discontinuous segments at indices " + String(i - 1) + ", " + String(i));
                    } else if (prevMax < currMin) {
                        this.segments.push(new EnvelopeSegment(segments[i - 1].p2, segments[i].p1));
                    }
                }
                this.segments.push(segments[i]);
            }
        }

        minX() {
            return this.segments[0].minX();
        }

        maxX() {
            return this.segments[this.segments.length - 1].maxX();
        }

        minY() {
            return Math.min(...this.segments.apply(x => x.p1.y), ...this.segments.apply(x => x.p2.y));
        }

        maxY() {
            return Math.max(...this.segments.apply(x => x.p1.y), ...this.segments.apply(x => x.p2.y));
        }

        addSegment(segment) {
            let segMinX = segment.minX();
            let maxX = this.maxX();

            if (segMinX === maxX) {
                this.segments.push(segment);
            } else if (segMinX > maxX) {
                this.segments.push(new EnvelopeSegment(this.segments[this.segments.length - 1].p2, segment.p1));
            } else {
                throw new Error("Discontinuous segment.");
            }
        }

        apply(audioParam, h_apply = EnvelopeHorizontal.offset_current_time,
              v_apply = EnvelopeVertical.vertical_idempotent,
              samplesPerSegment = EnvelopeSamples.smart_sample) {
            this.segments.forEach(x => x.apply(audioParam, samplesPerSegment(x), h_apply, v_apply));
        }
    }

    // Terminology

    // 0 -> C-1, 1 -> C#-1, etc., like MIDI in scientific pitch notation
    // Black notes are named as a sharp by default
    // Sharp -> #, Double sharp -> ##, Flat -> b, Double flat -> bb


    const octave_names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function mod(n, m) {
        return ((n % m) + m) % m;
    }

    function noteToName(note) {
        return octave_names[mod(note, 12)] + String(parseInt(note / 12) - 1);
    }

    function isNumber$1(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    const letter_nums = {
        "C": 0,
        "D": 2,
        "E": 4,
        "F": 5,
        "G": 7,
        "A": 9,
        "B": 11
    };

    const accidental_offsets = {
        "#": 1,
        "##": 2,
        "b": -1,
        "bb": -2
    };

    function nameToNote(name) {
        //                letter   accidental  -?  number
        let groups = /^([ABCDEFG])(#|##|B|BB)?(-)?([0-9]+)$/.exec(name.toUpperCase().trim());

        try {
            return letter_nums[groups[1]] +
                (groups[2] ? accidental_offsets[groups[2]] : 0) +
                (groups[3] ? -12 : 12) * (parseInt(groups[4])) + 12;
        } catch (e) {
            throw new Error("Invalid value.");
        }
    }

    const augmented_names = ["A", "AUG", "AUGMENTED"];
    const diminished_names = ["D", "DIM", "DIMIN", "DIMINISHED"];
    const perfect_names = ["P", "PERF", "PERFECT"];

    function getIntervalQuality(desc) {
        desc = desc.trim();
        if (desc[0] === "m" || desc[0] === "M") {
            let desc_upper = desc.toUpperCase();
            if (desc_upper.includes("MIN")) {
                return "min";
            } else if (desc_upper.includes("MAJ")) {
                return "maj";
            } else if (desc[0] === "m" && desc.length === 1) {
                return "min";
            } else if (desc[0] === "M" && desc.length === 1) {
                return "maj";
            } else {
                return null;
            }
        }
        let desc_upper = desc.toUpperCase();
        if (augmented_names.includes(desc_upper)) {
            return "aug";
        }
        if (diminished_names.includes(desc_upper)) {
            return "dim";
        }
        if (perfect_names.includes(desc_upper)) {
            return "perf";
        }
        return null;
    }

    function getIntervalSize(ord) {
        switch (ord) {
            case "1":
            case "one":
            case "first":
            case "1st":
            case "unison":
                return 1;
            case "2":
            case "two":
            case "second":
            case "2nd":
                return 2;
            case "3":
            case "three":
            case "third":
            case "3rd":
                return 3;
            case "four":
            case "fourth":
                return 4;
            case "five":
            case "fifth":
                return 5;
            case "six":
            case "sixth":
                return 6;
            case "seven":
            case "seventh":
                return 7;
            case "eight":
            case "eighth":
            case "octave":
                return 8;
            case "nine":
            case "ninth":
                return 9;
            case "ten":
            case "tenth":
                return 10;
            case "eleven":
            case "eleventh":
                return 11;
            case "twelve":
            case "twelfth":
                return 12;
            case "thirteen":
            case "thirteenth":
                return 13;
            case "fourteen":
            case "fourteenth":
                return 14;
            case "fifteen":
            case "fifteenth":
                return 15;
            case "sixteen":
            case "sixteenth":
                return 16;
            case "seventeen":
            case "seventeenth":
                return 17;
            case "eighteen":
            case "eighteenth":
                return 18;
            case "nineteen":
            case "nineteenth":
                return 19;
            case "twenty":
            case "twentieth":
                return 20;
        }
        let groups = /^([0-9]+)(th|)?$/.exec(ord);
        if (groups) {
            return parseInt(groups[1]);
        }
        return null;
    }

    function nameToInterval(name) {
        name = name.trim();
        let upper_name = name.toUpperCase();
        if (upper_name === "TT" || upper_name === "tritone") {
            return KeyboardIntervals.tritone;
        }
        if (upper_name === "unison") {
            return KeyboardIntervals.unison;
        }
        if (upper_name === "octave") {
            return KeyboardIntervals.octave;
        }
        let groups = /^([A-Za-z]+)\s*([A-Za-z0-9]+)$/.exec(name);

        if (!groups) {
            throw new Error("Invalid interval.");
        }

        let quality = getIntervalQuality(groups[1]);
        let value = getIntervalSize(groups[2]);

        if (!isNumber$1(value) || !quality || !value) {
            throw new Error("Invalid interval.");
        }

        let m_value = value % 7;
        let s_value = parseInt(value / 7);

        if ([4, 5, 1].includes(value % 7)) { // fourth, fifth, (unison, octave)
            value = s_value * 12;

            switch (m_value) {
                case 4:
                    value += 5;
                    break;
                case 5:
                    value += 7;
                    break;
                case 1:
                default:
            }

            switch (quality) {
                case "dim":
                    return new KeyboardInterval(value - 1);
                case "aug":
                    return new KeyboardInterval(value + 1);
                case "perf":
                    return new KeyboardInterval(value);
                default:
                case "min":
                case "maj":
                    throw new Error("Invalid interval.");
            }
        } else {
            value = s_value * 12;

            switch (m_value) {
                case 0: // seventh
                    value += 11;
                    break;
                case 2: // second
                    value += 2;
                    break;
                case 3: // third
                    value += 4;
                    break;
                case 6: // fourth
                    value += 9;
                    break;
            }

            switch (quality) {
                case "dim":
                    return new KeyboardInterval(value - 2);
                case "aug":
                    return new KeyboardInterval(value + 1);
                case "min":
                    return new KeyboardInterval(value - 1);
                case "maj":
                    return new KeyboardInterval(value);
                default:
                case "perf":
                    throw new Error("Invalid interval.");
            }
        }
    }

    function intervalToName(interval_size) {
        let s_value = interval_size % 12;
        let m_value = parseInt(interval_size / 12);

        let prefix;
        let v_value;

        switch (s_value) {
            case 0:
                prefix = "P";
                v_value = 1;
                break;
            case 1:
                prefix = "m";
                v_value = 2;
                break;
            case 2:
                prefix = "M";
                v_value = 2;
                break;
            case 3:
                prefix = "m";
                v_value = 3;
                break;
            case 4:
                prefix = "M";
                v_value = 3;
                break;
            case 5:
                prefix = "P";
                v_value = 4;
                break;
            case 6:
                prefix = "A";
                v_value = 4;
                break;
            case 7:
                prefix = "P";
                v_value = 5;
                break;
            case 8:
                prefix = "m";
                v_value = 6;
                break;
            case 9:
                prefix = "M";
                v_value = 6;
                break;
            case 10:
                prefix = "m";
                v_value = 7;
                break;
            case 11:
                prefix = "M";
                v_value = 7;
                break;
        }

        let value = m_value * 7 + v_value;

        return prefix + String(value);
    }

    const KeyboardIntervals = {
        unison: 0,
        minor_second: 1,
        major_second: 2,
        minor_third: 3,
        major_third: 4,
        perfect_fourth: 5,
        tritone: 6,
        perfect_fifth: 7,
        minor_sixth: 8,
        major_sixth: 9,
        minor_seventh: 10,
        major_seventh: 11,
        octave: 12
    };

    function _isKeyboardNoteInstance(note) {
        return (note instanceof KeyboardPitch);
    }

    function _isKeyboardIntervalInstance(interval) {
        return (interval instanceof KeyboardInterval);
    }

    class KeyboardPitch {
        constructor(note) {
            if (isNumber$1(note)) {
                this.value = note;
            } else if (_isKeyboardNoteInstance(note)) {
                this.value = note.value;
            } else {
                this.value = nameToNote(note);
            }
        }

        subtract(note) { // or Interval
            if (_isKeyboardNoteInstance(note) || isNumber$1(note)) {
                return new KeyboardInterval(this.value - new KeyboardPitch(note).value);
            } else if (_isKeyboardIntervalInstance(note)) {
                return new KeyboardPitch(this.value - note.value);
            }
        }

        add(interval) {
            return new KeyboardPitch(this.value + interval.value);
        }

        name() {
            return noteToName(this.value);
        }

        twelveTETFrequency() {
            return Math.pow(2, (this.value - 69) / 12) * 440;
        }
    }

    function makeKeyboardPitch(...args) {
        return new KeyboardPitch(...args);
    }

    class KeyboardInterval {
        constructor(arg1, arg2) {
            if (isNumber$1(arg1) && arg2 === undefined) {
                this.value = arg1;
            } else if (arg2 !== undefined) {
                this.value = new KeyboardPitch(arg2).subtract(new KeyboardPitch(arg1)).value;
            } else if (_isKeyboardIntervalInstance(arg1)) {
                this.value = arg1.value;
            } else if (typeof arg1 === "string") {
                this.value = nameToInterval(arg1).value;
            }
        }

        add(interval) {
            return new KeyboardInterval(this.value + (new KeyboardInterval(interval)).value);
        }

        subtract(interval) {
            return new KeyboardInterval(this.value - (new KeyboardInterval(interval)).value);
        }

        negate() {
            return new KeyboardInterval(-this.value)
        }

        cents() { // 12-TET
            return this.value * 100;
        }

        ratio() {
            return Math.pow(2, this.value / 12);
        }

        name() {
            return intervalToName(this.value);
        }
    }

    function makeKeyboardInterval(...args) {
        return new KeyboardInterval(...args);
    }

    for (let key in KeyboardIntervals) {
        KeyboardIntervals[key] = new KeyboardInterval(KeyboardIntervals[key]);
    }

    Object.freeze(KeyboardIntervals);

    const KeyboardPitches = {};

    for (let i = 12; i < 128; i++) { // C0 to G9, notes for easy access
        let note = new KeyboardPitch(i);

        KeyboardPitches[note.name().replace("#", "s")] = note;
    }

    class KeyboardMapping {
        constructor(dict, func) { // Key pathway: (keypress / keyup) -> dict -> func call (KeyboardPitch, bool pressed)
            this.keydict = dict;
            this.func = func;
            this.enabled = false;
            this.keyPress = (evt => {
                try {
                    this.func(this.keydict[evt.key], true);
                } catch (e) {
                    // Key that's not in the mapping, ok
                }
            });
            this.keyUp = (evt => {
                try {
                    this.func(this.keydict[evt.key], false);
                } catch (e) {
                    // Key that's not in the mapping, ok
                }
            });
        }

        enable() {
            if (!this.enabled) {
                document.addEventListener("keypress", this.keyPress);
                document.addEventListener("keyup", this.keyUp);
                this.enabled = true;
            }
        }

        disable() {
            if (this.enabled) {
                document.removeEventListener("keypress", this.keyPress);
                document.removeEventListener("keyup", this.keyUp);
                this.enabled = false;
            }
        }

        dictApply(func) {
            for (let key in this.keydict) {
                this.keydict[key] = func(this.keydict[key]);
            }
        }

        transform(key) {
            return this.keydict[key];
        }

        virtualPress(key) {
            this.func(this.keydict[key], true);
        }

        virtualRelease(key) {
            this.func(this.keydict[key], false);
        }
    }

    let N = KeyboardPitches;

    let _DefaultKeyboardMapping = {
        "z" : N.C3,
        "s" : N.Cs3,
        "x" : N.D3,
        "d" : N.Ds3,
        "c" : N.E3,
        "v" : N.F3,
        "g" : N.Fs3,
        "b" : N.G3,
        "h" : N.Gs3,
        "n" : N.A3,
        "j" : N.As3,
        "m" : N.B3,
        "," : N.C4,
        "l" : N.Cs4,
        "." : N.D4,
        ";" : N.Ds4,
        "/" : N.E4,
        "q" : N.C4,
        "2" : N.Cs4,
        "w" : N.D4,
        "3" : N.Ds4,
        "e" : N.E4,
        "r" : N.F4,
        "5" : N.Fs4,
        "t" : N.G4,
        "6" : N.Gs4,
        "y" : N.A4,
        "7" : N.As4,
        "u" : N.B4,
        "i" : N.C5,
        "9" : N.Cs5,
        "o" : N.D5,
        "0" : N.Ds5,
        "p" : N.E5,
        "[" : N.F5,
        "=" : N.Fs5,
        "]" : N.G5
    };

    function getDefaultKeyboardDict() {
        return Object.assign({}, _DefaultKeyboardMapping);
    }

    class KeyboardInstrument extends Instrument {
        constructor() {
            super();

            this.keyboard = {};
            for (let i = 0; i < 128; i++) {
                this.keyboard[i] = false;
            }
        }

        play(note) {
            note = new KeyboardPitch(note);
            if (!this.keyboard[note.value]) {
                this.keyboard[note.value] = true;
                this.onplay(note);
            }
        }

        release(note) {
            note = new KeyboardPitch(note);
            if (this.keyboard[note.value]) {
                this.keyboard[note.value] = false;
                this.onrelease(note);
            }
        }

        releaseAll(notes) {
            for (let i = 0; i < 128; i++) {
                this.release(i);
            }
        }
    }

    function clamp(value, min, max, name) {
        if (value > max) {
            console.warn(`Value ${name} outside nominal range [${min}, ${max}]; value will be clamped.`);
            return max;
        } else if (value < min) {
            console.warn(`Value ${name} outside nominal range [${min}, ${max}]; value will be clamped.`);
            return min;
        } else {
            return value;
        }
    }

    const MAX_DETUNE_CENTS = 200;
    const MIN_FREQUENCY = -22050;
    const MAX_FREQUENCY = 22050;
    const MIN_BLEND = 0;
    const MAX_BLEND = 1;
    const MAX_UNISON = 16;

    function blendMapping(x) {
        if (x === 0) {
            return 0;
        } else if (0 < x && x <= 1) {
            return x - 1;
        } else {
            return x + 1;
        }
    }

    class UnisonOscillator {
        constructor(parameters = {}) {

            this._frequency = clamp(parameters.frequency || 440, MIN_FREQUENCY, MAX_FREQUENCY, "frequency"); // frequency of average oscillation
            this._detune = clamp((parameters.detune === 0) ? 0 : (parameters.detune || 20), 0, MAX_DETUNE_CENTS, "detune"); // spread width of oscillators (symmetric)
            this._unison_obj = {value : clamp((parameters.unison || 4), 2, MAX_UNISON)}; // Number of oscillators

            Object.freeze(this._unison_obj);
            this._blend = clamp((parameters.blend === 0) ? 0 : (parameters.blend || 0.5), MIN_BLEND, MAX_BLEND, "blend"); // ratio (gain of centermost oscillators) / (gain of peripheral oscillators)
            this._type = parameters.type || "triangle"; // type of waveform

            this._context = exports.Context;
            this.exit_node = exports.Context.createGain();
            // this.exit_node.gain.setValueAtTime(1 / this.unison, 0);
            this.oscillators = [];

            let unison = this.unison;

            if (unison % 2 === 0) {
                let centerBlend = this._blend;
                let peripheralBlend = 1 - this._blend;
                let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                this.exit_node.gain.value = 1 / loudness;

                for (let i = 0; i < unison; i++) {
                    let series = {d: (i - unison / 2 + 1 / 2) / (unison - 1),
                        o: exports.Context.createOscillator(),
                        g: exports.Context.createGain(),
                        delay: exports.Context.createDelay(),
                        pan: exports.Context.createStereoPanner()
                    };

                    series.o.frequency.setValueAtTime(this._frequency, 0);
                    series.o.detune.setValueAtTime(series.d * this._detune, 0);
                    series.o.type = this._type;
                    series.delay.delayTime.setValueAtTime(1 / this._frequency * Math.random(), 0);

                    if (unison === 2) {
                        series.pan.pan.setValueAtTime(series.d * 2, 0);
                    } else {
                        series.pan.pan.setValueAtTime(blendMapping(series.d * 2), 0);
                    }

                    if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                        series.g.gain.setValueAtTime(centerBlend, 0);
                    } else {
                        series.g.gain.setValueAtTime(peripheralBlend, 0);
                    }

                    chainNodes([
                        series.o,
                        series.delay,
                        series.g,
                        series.pan,
                        this.exit_node
                    ]);

                    this.oscillators.push(series);
                }
            } else {
                let centerBlend = this._blend;
                let peripheralBlend = 1 - this._blend;
                let loudness = centerBlend + (unison - 1) * peripheralBlend;

                this.exit_node.gain.value = 1 / loudness;

                for (let i = 0; i < unison; i++) {
                    let series = {d: (i - unison / 2 + 1 / 2) / (unison - 1),
                        o: exports.Context.createOscillator(),
                        g: exports.Context.createGain(),
                        delay: exports.Context.createDelay(),
                        pan: exports.Context.createStereoPanner()
                    };

                    series.o.frequency.setValueAtTime(this._frequency, 0);
                    series.o.detune.setValueAtTime(series.d * this._detune, 0);
                    series.o.type = this._type;
                    series.delay.delayTime.setValueAtTime(1 / this._frequency * Math.random(), 0);

                    if (unison === 3) {
                        series.pan.pan.setValueAtTime(series.d * 2, 0);
                    } else {
                        series.pan.pan.setValueAtTime(blendMapping(series.d * 2), 0);
                    }

                    if (i === (unison - 1) / 2) {
                        series.g.gain.setValueAtTime(centerBlend, 0);
                    } else {
                        series.g.gain.setValueAtTime(peripheralBlend, 0);
                    }

                    chainNodes([
                        series.o,
                        series.delay,
                        series.g,
                        series.pan,
                        this.exit_node
                    ]);

                    this.oscillators.push(series);
                }
            }

            this.channelCount = 2;
            this.channelCountMode = "max";
            this.channelInterpretation = "speakers";

            let that = this;

            this.frequency = {
                setValueAtTime: (value, time) => {
                    value = clamp(value, MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.setValueAtTime(value, time);
                    }
                },
                linearRampToValueAtTime: (value, time) => {
                    value = clamp(value, MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.linearRampToValueAtTime(value, time);
                    }
                },
                exponentialRampToValueAtTime: (value, time) => {
                    value = clamp(value, MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.exponentialRampToValueAtTime(value, time);
                    }
                },
                setTargetAtTime: (value, startTime, constantTime) => {
                    value = clamp(value, MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.setTargetAtTime(value, startTime, constantTime);
                    }
                },
                setValueCurveAtTime: (table, startTime, endTime) => {
                    for (let i = 0; i < table.length; i++) {
                        table[i] = clamp(table[i], MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    }
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.setValueCurveAtTime(table, startTime, endTime);
                    }
                },
                cancelScheduledValues: () => {
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.frequency.cancelScheduledValues();
                    }
                },
                get value() {
                    return that.oscillators[0].o.frequency.value;
                },
                set value(value) {
                    value = clamp(value, MIN_FREQUENCY, MAX_FREQUENCY, "frequency");
                    for (let i = 0; i < that.unison; i++) {
                        that.oscillators[i].o.frequency.value = value;
                    }
                }
            };

            Object.defineProperties(this.frequency, {
                minValue: {
                    value: MIN_FREQUENCY,
                    writable: false
                },
                maxValue: {
                    value: MAX_FREQUENCY,
                    writable: false
                },
                defaultValue: {
                    value: 440,
                    writable: false
                }
            });

            this.detune = {
                setValueAtTime: (value, time) => {
                    value = clamp(value, 0, that.detune.maxValue, "detune");

                    for (let i = 0; i < this.unison; i++) {
                        let series = this.oscillators[i];
                        series.o.detune.setValueAtTime(series.d * value, time);
                    }
                },
                linearRampToValueAtTime: (value, time) => {
                    value = clamp(value, 0, that.detune.maxValue, "detune");

                    for (let i = 0; i < this.unison; i++) {
                        let series = this.oscillators[i];
                        series.o.detune.linearRampToValueAtTime(series.d * value, time);
                    }
                },
                exponentialRampToValueAtTime: (value, time) => {
                    value = clamp(value, 0, that.detune.maxValue, "detune");

                    for (let i = 0; i < this.unison; i++) {
                        let series = this.oscillators[i];
                        series.o.detune.exponentialRampToValueAtTime(series.d * value, time);
                    }
                },
                setTargetAtTime: (value, startTime, constantTime) => {
                    value = clamp(value, 0, that.detune.maxValue, "detune");

                    for (let i = 0; i < this.unison; i++) {
                        let series = this.oscillators[i];
                        series.o.detune.setTargetAtTime(series.d * value, startTime, constantTime);
                    }
                },
                setValueCurveAtTime: (table, startTime, endTime) => {
                    for (let i = 0; i < table.length; i++) {
                        table[i] = clamp(table[i], 0, that.detune.maxValue, "detune");
                    }
                    for (let i = 0; i < this.unison; i++) {
                        let series = this.oscillators[i];
                        let newTable = table.slice();

                        for (let j = 0; j < newTable.length; j++) {
                            newTable[j] = series.d * newTable[j];
                        }

                        series.o.detune.setValueCurveAtTime(newTable, startTime, endTime);
                    }
                },
                cancelScheduledValues: () => {
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].o.detune.cancelScheduledValues();
                    }
                },
                get value() {
                    return that.oscillators[0].o.detune.value / that.oscillators[0].d;
                },
                set value(value) {
                    value = clamp(value, 0, that.detune.maxValue, "detune");

                    for (let i = 0; i < that.unison; i++) {
                        let series = that.oscillators[i];
                        series.o.detune.value = series.d * value;
                    }
                }
            };

            Object.defineProperties(this.detune, {
                minValue: {
                    value: 0,
                    writable: false
                },
                maxValue: {
                    value: MAX_DETUNE_CENTS,
                    writable: false
                },
                defaultValue: {
                    value: 50,
                    writable: false
                }
            });

            // TODO: Allow blend enveloping and such, not trivial, might not actually do it
            this.blend = {
                get value() {
                    if (that.unison % 2 === 0) {
                        return that.oscillators[that.unison / 2].g.gain.value;
                    } else {
                        return that.oscillators[(that.unison - 1) / 2].g.gain.value;
                    }
                },
                set value(value) {
                    value = clamp(value, MIN_BLEND, MAX_BLEND, "blend");
                    if (that.unison % 2 === 0) {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                        that.exit_node.gain.value = 1 / loudness;

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.value = centerBlend;
                            } else {
                                series.g.gain.value = peripheralBlend;
                            }
                        }
                    } else {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = centerBlend + (unison - 1) * peripheralBlend;

                        that.exit_node.gain.value = 1 / loudness;

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.setValueAtTime(centerBlend, 0);
                            } else {
                                series.g.gain.setValueAtTime(peripheralBlend, 0);
                            }
                        }
                    }
                },
                setValueAtTime(value, time) {
                    value = clamp(value, MIN_BLEND, MAX_BLEND, "blend");
                    if (that.unison % 2 === 0) {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                        that.exit_node.gain.setValueAtTime(1 / loudness, time);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.setValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.setValueAtTime(peripheralBlend, time);
                            }
                        }
                    } else {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = centerBlend + (unison - 1) * peripheralBlend;

                        that.exit_node.gain.setValueAtTime(1 / loudness, time);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.setValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.setValueAtTime(peripheralBlend, time);
                            }
                        }
                    }
                },
                linearRampToValueAtTime: (value, time) => {
                    value = clamp(value, MIN_BLEND, MAX_BLEND, "blend");
                    if (that.unison % 2 === 0) {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                        that.exit_node.gain.linearRampToValueAtTime(1 / loudness, time);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.linearRampToValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.linearRampToValueAtTime(peripheralBlend, time);
                            }
                        }
                    } else {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = centerBlend + (unison - 1) * peripheralBlend;

                        that.exit_node.gain.linearRampToValueAtTime(1 / loudness, time);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.linearRampToValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.linearRampToValueAtTime(peripheralBlend, time);
                            }
                        }
                    }
                },
                exponentialRampToValueAtTime: (value, time) => {
                    console.warn("exponentialRampToValueAtTime for UnisonOscillator.blend does not work well.");

                    value = clamp(value, MIN_BLEND, MAX_BLEND, "blend");

                    if (that.unison % 2 === 0) {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                        that.exit_node.gain.exponentialRampToValueAtTime(1 / loudness, time);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.exponentialRampToValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.exponentialRampToValueAtTime(peripheralBlend, time);
                            }
                        }
                    } else {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = centerBlend + (unison - 1) * peripheralBlend;

                        that.exit_node.gain.value = 1 / loudness;

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.exponentialRampToValueAtTime(centerBlend, time);
                            } else {
                                series.g.gain.exponentialRampToValueAtTime(peripheralBlend, time);
                            }
                        }
                    }
                },
                setTargetAtTime: (value, startTime, constantTime) => {
                    value = clamp(value, MIN_BLEND, MAX_BLEND, "blend");
                    if (that.unison % 2 === 0) {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = 2 * centerBlend + (unison - 2) * peripheralBlend;

                        that.exit_node.gain.setTargetAtTime(1 / loudness, startTime, constantTime);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.setTargetAtTime(centerBlend, startTime, constantTime);
                            } else {
                                series.g.gain.setTargetAtTime(peripheralBlend, startTime, constantTime);
                            }
                        }
                    } else {
                        let centerBlend = value;
                        let peripheralBlend = 1 - value;
                        let loudness = centerBlend + (unison - 1) * peripheralBlend;

                        that.exit_node.gain.linearRampToValueAtTime(1 / loudness, startTime, constantTime);

                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.setTargetAtTime(centerBlend, startTime, constantTime);
                            } else {
                                series.g.gain.setTargetAtTime(peripheralBlend, startTime, constantTime);
                            }
                        }
                    }
                },
                setValueCurveAtTime: (table, startTime, endTime) => {
                    for (let i = 0; i < table.length; i++) {
                        table[i] = clamp(table[i], MIN_BLEND, MAX_BLEND, "blend");
                    }
                    let centerBlendTable = new Float32Array(table.length);
                    let peripheralBlendTable = centerBlendTable.slice();
                    let loudnessTable = centerBlendTable.slice();

                    for (let i = 0; i < table.length; i++) {
                        let value = i;
                        if (that.unison % 2 === 0) {
                            var centerBlend_ = value;
                            var peripheralBlend_ = 1 - value;
                            var loudness_ = 2 * centerBlend_ + (unison - 2) * peripheralBlend_;
                        } else {
                            var centerBlend_ = value;
                            var peripheralBlend_ = 1 - value;
                            var loudness_ = centerBlend_ + (unison - 1) * peripheralBlend_;
                        }

                        centerBlendTable[i] = centerBlend_;
                        peripheralBlendTable[i] = peripheralBlend_;
                        loudnessTable[i] = 1 / loudness_;
                    }

                    if (that.unison % 2 === 0) {
                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                             if (i === unison / 2 - 1 || i === unison / 2 || unison === 2) {
                                series.g.gain.setValueCurveAtTime(centerBlendTable, startTime, endTime);
                            } else {
                                series.g.gain.setValueCurveAtTime(peripheralBlendTable, startTime, endTime);
                            }
                        }
                    } else {
                        for (let i = 0; i < that.unison; i++) {
                            let series = that.oscillators[i];

                            if (i === (unison - 1) / 2) {
                                series.g.gain.setValueCurveAtTime(centerBlendTable, startTime, endTime);
                            } else {
                                series.g.gain.setValueCurveAtTime(peripheralBlendTable, startTime, endTime);
                            }
                        }
                    }

                    this.exit_node.gain.setValueCurveAtTime(loudnessTable, startTime, endTime);
                },
                cancelScheduledValues: () => {
                    for (let i = 0; i < this.unison; i++) {
                        this.oscillators[i].g.gain.cancelScheduledValues();
                    }
                }
            };

            Object.defineProperties(this.blend, {
                minValue: {
                    value: MIN_BLEND,
                    writable: false
                },
                maxValue: {
                    value: MAX_BLEND,
                    writable: false
                },
                defaultValue: {
                    value: 0.5,
                    writable: false
                }
            });

            delete this._frequency;
            delete this._detune;
            delete this._blend;
        }

        get unison() {
            return this._unison_obj.value;
        }

        get type() {
            return this._type;
        }

        set type(value) {
            this._type = value;
            for (let i = 0; i < this.unison; i++) {
                this.oscillators[i].o.type = value;
            }
        }

        static get numberOfInputs() {
            return 0;
        }

        static get numberOfOutputs() {
            return 1;
        }

        static get context() {
            return this._context;
        }

        connect(node) {
            this.exit_node.connect(node);
        }

        disconnect() {
            this.exit_node.disconnect();
        }

        start(time = this._context.currentTime) {
            for (let i = 0; i < this.oscillators.length; i++) {
                let series = this.oscillators[i];

                series.o.start(time);
            }
        }

        stop(time = this._context.currentTime) {
            for (let i = 0; i < this.oscillators.length; i++) {
                let series = this.oscillators[i];

                series.o.stop(time);
            }
        }
    }

    // Hz is associated with Frequencies
    // ratio is associated with Intervals

    function _isFrequency(obj) {
        return !!obj.Hz;
    }

    function _isInterval(obj) {
        return !!obj.ratio;
    }

    class Pitch {
        constructor(value) {
            if (_isFrequency(value)) {
                this.value = value.value;
            } else if (value instanceof KeyboardPitch) {
                this.value = value.twelveTETFrequency();
            } else {
                this.value = value; // value is in Hz
            }
        }

        Hz() { // Hz
            return this.value;
        }

        period() { // seconds
            return 1 / this.value;
        }

        add(interval) {
            return new Pitch(this.value * interval.ratio());
        }

        subtract(note) {
            if (note.ratio) { // subtracting interval
                return new Pitch(this.value / interval.ratio());
            } else {
                return new Interval(note.value / this.value);
            }
        }
    }

    function isNumber$2(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    let intervalUnits = {
        cents : 1.000577789506554859297,
        schismas : 1.001129150390625,
        semitones : 1.059463094359295264562,
        tones: 1.122462048309372981434,
        tritones: 1.414213562373095048802,
        octaves: 2,
        millioctaves: 1.000693387462580632538,
        savarts: 1.002305238077899671915,
        decades: 10,
        merides: 1.016248692870695627673,
        heptamerides: 1.002305238077899671915,
        demiheptamerides: 1.001151955538168876984,
        decamerides: 1.000230285020824752684,
        jots: 1.000023026116026880671,
        syntonic_commas: 81/80,
        pythagorean_commas: 531441 / 524288
    };

    function getIntervalFromObj(obj) {
        let interval_out = new Interval(1);

        for (let key in intervalUnits) {
            if (obj[key]) {
                interval_out = interval_out.add(intervalUnits[key].stack(obj[key]));
            }
        }

        return interval_out;
    }

    class Interval {
        constructor(arg1, arg2) {
            if (arg1 && arg2) { // difference between two frequency
                arg1 = new Pitch(arg1);
                arg2 = new Pitch(arg2);

                this.value = arg2.Hz() / arg1.Hz();
            } else if (arg1) {
                if (isNumber$2(arg1)) {
                    this.value = arg1;
                } else if (_isInterval(arg1)) {
                    this.value = arg1.value;
                } else {
                    if (arg1 instanceof KeyboardInterval) {
                        this.value = arg1.ratio();
                    } else {
                        this.value = getIntervalFromObj(arg1).value;
                    }
                }
            }
        }

        reverse() {
            return new Interval(1 / this.value);
        }

        subtract(interval, times = 1) {
            return new Interval(this.value / interval.stack(times).value);
        }

        add(interval, times = 1) {
            return new Interval(this.value * interval.stack(times).value);
        }

        divideByInterval(interval) {
            return Math.log(this.value, interval.value);
        }

        divide(number) {
            return new Interval(Math.pow(this.value, 1 / number));
        }

        stack(times = 1) {
            return new Interval(Math.pow(this.value, times));
        }

        ratio() {
            return this.value;
        }
    }

    for (let key in intervalUnits) {
        intervalUnits[key] = new Interval(intervalUnits[key]);
    }

    function makePitch(...args) {
        return new Pitch(...args);
    }

    function makeInterval(...args) {
        return new Interval(...args);
    }

    let TwelveTETIntervals = {
        unison: 1,
        minor_second: {cents: 100},
        semitone: {cents : 100},
        major_second: {cents : 200},
        tone: {cents: 200},
        whole_tone : {cents: 200},
        minor_third: {cents: 300},
        major_third: {cents: 400},
        perfect_fourth: {cents: 500},
        tritone: {cents: 600},
        perfect_fifth: {cents: 700},
        minor_sixth : {cents: 800},
        major_sixth : {cents: 900},
        minor_seventh: {cents: 1000},
        major_seventh: {cents: 1100},
        octave: 2
    };

    class PitchMapping {
        constructor(pitchDict, pitchMap = (x => x), kPitchMap = (x => x)) {
            this.dict = pitchDict;
            this.pitchMap = pitchMap; // Changing a frequency
            this.kPitchMap = kPitchMap; // Changing the nominal meaning of a keyboard pitch
        }

        transform(keyboardPitch) {
            return this.pitchMap(this.dict[this.kPitchMap(keyboardPitch.value)]);
        }

        dictApply(func) {
            for (let key in this.dict) {
                this.keydict[key] = func(this.keydict[key]);
            }
        }
    }

    let twelveTETDict = {};

    for (let i = 0; i < 128; i++) {
        twelveTETDict[i] = (new KeyboardPitch(i)).twelveTETFrequency();
    }

    let twelveTETMapping = new PitchMapping(twelveTETDict);

    let PitchMappings = {
        ET12 : twelveTETMapping
    };

    function pitchMappingFromScale(scale, baseNote = Tones.KeyboardPitches.C4, baseFrequency) {
        // scale is array of intervals or single arguments to an interval constructor

        scale = scale.map(f => new Interval(f));

        let scale_length = scale.length;
        let scale_repeating_interval = scale[scale_length - 1];
        baseFrequency = new Pitch(baseFrequency || baseNote.twelveTETFrequency());

        let dict = {};

        let scaleRepeats = Math.ceil((baseNote.value + 1) / scale_length);
        let bottom = baseNote.value - scaleRepeats * scale_length;

        for (let offset = bottom, scaleR = -scaleRepeats; offset < 129; offset += scale_length, scaleR++) {
            for (let i = offset + 1, j = 0; j < scale_length; i++, j++) {
                dict[i] = baseFrequency.add(scale[j]).add(scale_repeating_interval.stack(scaleR)).Hz();
            }
        }

        return new PitchMapping(dict);
    }

    let a = new EnvelopeSegment([0,0], [0.01,1]);
    let b = new EnvelopeSegment(a.p2, [1, 0.2], 0.4);

    const DefaultAttackEnvelope = new Envelope([a,b]);

    class SimpleInstrument extends KeyboardInstrument {
        constructor(parameters = {}) {
            super();

            this.params = {};

            this.params.unison = parameters.unison || 8; // Unison (integer >= 1)
            this.params.detune = (parameters.detune === 0) ? 0 : (parameters.detune || 20); // Spread of detune (cents)
            this.params.blend = (parameters.blend === 0) ? 0 : (parameters.blend || 0.6); // Blend between central and peripheral oscillators
            this.params.release_length = (parameters.release_length === 0) ? 0 : (parameters.release_length || 0.1); // Decay (sec)
            this.params.attack_envelope = (parameters.attack_envelope || DefaultAttackEnvelope);
            this.params.waveform = parameters.waveform || "square";

            if (parameters.destinationNode) {
                this.connect(parameters.destinationNode);
            }

            this.oscillators = {};
            for (let i = 0; i < 128; i++) {
                this.oscillators[i] = null;
            }

            this.createReleaseEnvelope = (gain_value) => {
                return new Envelope([new EnvelopeSegment([0, gain_value], [this.params.release_length, 0])]);
            };

            this.keyboard_mapping = new KeyboardMapping(parameters.keyboard_dict || getDefaultKeyboardDict(),
                (note, pressing) => {
                    if (!note) return;
                    if (pressing) {
                        this.play(note);
                    } else {
                        this.release(note);
                    }
            });

            this.pitch_mapping = parameters.pitch_mapping || PitchMappings.ET12;
        }

        onplay(note) {
            if (this.params.unison === 1) {
                var tone = exports.Context.createOscillator();
            } else {
                var tone = new UnisonOscillator(this.params);
            }

            let tone_gain = exports.Context.createGain();

            chainNodes([
                tone,
                tone_gain,
                this.entryNode]);


            tone.type = this.waveform;
            tone.frequency.value = this.pitch_mapping.transform(note);
            tone_gain.gain.setValueAtTime(0, 0);
            tone.start();

            this.params.attack_envelope.apply(tone_gain.gain,
                EnvelopeHorizontal.offset_current_time,
                EnvelopeVertical.vertical_exp);

            this.oscillators[note.value] = {tone: tone, tone_gain: tone_gain};
        }

        onrelease(note) {
            let group = this.oscillators[note.value];

            group.tone_gain.gain.cancelScheduledValues(0);
            this.createReleaseEnvelope(
                EnvelopeVerticalInverse.vertical_exp(group.tone_gain.gain.value)
                // We invert the value because it was transformed by EnvelopeVertical.vertical_exp
            ).apply(group.tone_gain.gain,
                EnvelopeHorizontal.offset_current_time,
                EnvelopeVertical.vertical_exp);

            this.oscillators[note.value] = null;
            let toneGain = group.tone_gain;
            let tone = group.tone;
            removeNodesTimeout([toneGain, tone], this.params.release_length + 0.1);
        }

        get keyboardPlayEnabled() {
            return this.keyboard_mapping.enabled;
        }

        set keyboardPlayEnabled(boolean) {
            if (boolean) {
                enableKeyboardPlay();
            } else {
                disableKeybordPlay();
            }
        }

        enableKeyboardPlay() {
            this.keyboard_mapping.enable();
        }

        disableKeyboardPlay() {
            this.keyboard_mapping.disable();
            this.releaseAll();
        }

        oscillatorApply(func) {
            for (let i = 0; i < 128; i++) {
                if (this.oscillators[i]) {
                    func(this.oscillators[i], i);
                }
            }
        }

        set detune(value) {
            this.params.detune = value;
            this.oscillatorApply(function(x) {
                x.tone.detune.value = value;
            });
        }

        get detune() {
            return this.params.detune;
        }

        set blend(value) {
            this.params.blend = value;
            this.oscillatorApply(function(x) {
                x.tone.blend.value = value;
            });
        }

        get blend() {
            return this.params.blend;
        }

        set waveform(value) {
            this.params.waveform = value;
            this.oscillatorApply(function(x) {
                x.tone.type = value;
            });
        }

        get waveform() {
            return this.params.waveform;
        }
    }

    let a$1 = new EnvelopeSegment([0,0], [0.005,1], 0.9);
    let b$1 = new EnvelopeSegment(a$1.p2, [2.4, 0.2], 0.5);
    let c = new EnvelopeSegment(b$1.p2, [20, 0], 0.1);

    const DefaultAttackEnvelope$1 = new Envelope([a$1,b$1,c]);

    const real = new Float32Array([0,0,1,0,1]);
    const imag = new Float32Array(real.length);
    const pianoWave = exports.Context.createPeriodicWave(real,imag);

    class PianoOscillator {
        constructor(frequency) {
            this.oscillator_count = 15;

            this.oscillators = [];
            this.exit_node = exports.Context.createGain();

            let r = 0.7; // radius of string, mm
            let E = 200000; // Young's modulus of string, Newtons / (mm) ^ 2
            let T = 1600; // Tension of string, newtons
            let L = 1000; // Length of string, mm


            let A = Math.pow(Math.PI, 3) * r * r * r * r * E / 8 / T / L / L;

            let partials = [
                1.7202996385444569, 1.4300663282061981, 1.1597951953657128, 0.58661553936616362, 0.33257550015829651, 0.32094063539074608, 0.15592066374569108, 0.17132499997971729, 0.14850610765546846, 0.1738548266767786, 0.034705710530054883, 0.012656264005633504, 0.02067379392384007, 0.0052896371953956084, 0.067187378351302077, 0.0033300110566908026, 0.004430089629984711, 0.00077412060834818562, 0.00090773026428330383, 0.00076213801712951763, 0.00072315653323779948, 0.0009126541447556396, 0.00074440438139133089, 0.0004686624661097702
                ];
            let volume = 0;

            for (let i = 1; i < this.oscillator_count + 1; i++) {
                let series = {
                    o: exports.Context.createOscillator(),
                    g: exports.Context.createGain(),
                    d: exports.Context.createDelay(),
                    pan: exports.Context.createStereoPanner()
                };

                series.o.frequency.value = i * frequency * Math.sqrt(1 + A * i * i);
                series.g.gain.value = partials[i];
                volume += partials[i];
                series.d.delayTime.value = Math.random() / i / frequency;
                series.pan.pan.value = Math.random() / 2;

                chainNodes([series.o, series.g, series.d, series.pan, this.exit_node]);

                this.oscillators.push(series);
            }

            this.exit_node.gain.value = 1 / volume;
        }

        connect(node) {
            this.exit_node.connect(node);
        }

        start() {
            for (let i = 0; i < this.oscillator_count; i++) {
                this.oscillators[i].o.start();
            }
        }

        stop() {
            for (let i = 0; i < this.oscillator_count; i++) {
                this.oscillators[i].o.stop();
            }
        }

        disconnect() {
            this.exit_node.disconnect();
        }
    }

    class Piano extends KeyboardInstrument {
        constructor(parameters = {}) {
            super();

            this.params = {};

            this.params.unison = parameters.unison || 8; // Unison (integer > 1)
            this.params.detune = (parameters.detune === 0) ? 0 : (parameters.detune || 20); // Spread of detune (cents)
            this.params.blend = (parameters.blend === 0) ? 0 : (parameters.blend || 0.6); // Blend between central and peripheral oscillators
            this.params.release_length = (parameters.release_length === 0) ? 0 : (parameters.release_length || 0.1); // Decay (sec)
            this.params.attack_envelope = (parameters.attack_envelope || DefaultAttackEnvelope$1);

            if (parameters.destinationNode) {
                this.connect(parameters.destinationNode);
            }

            this.oscillators = {};
            for (let i = 0; i < 128; i++) {
                this.oscillators[i] = null;
            }

            this.createDecayEnvelope = (gain_value) => {
                return new Envelope([new EnvelopeSegment([0, gain_value], [this.params.release_length, 0])]);
            };

            this.keyboard_mapping = new KeyboardMapping(parameters.keyboard_dict || getDefaultKeyboardDict(),
                (note, pressing) => {
                    if (!note) return;
                    if (pressing) {
                        this.play(note);
                    } else {
                        this.release(note);
                    }
                });

            this.pitch_mapping = parameters.pitch_mapping || PitchMappings.ET12;
        }

        onplay(note) {
            try {
                let tone = new PianoOscillator(this.pitch_mapping.transform(note));
                // let tone = audio.Context.createOscillator();
                let tone_gain = exports.Context.createGain();

                chainNodes([
                    tone,
                    tone_gain,
                    this.entryNode
                ]);

                tone_gain.gain.setValueAtTime(0, 0);
                tone.start();

                this.params.attack_envelope.apply(tone_gain.gain,
                    EnvelopeHorizontal.offset_current_time,
                    EnvelopeVertical.vertical_exp);

                this.oscillators[note.value] = {tone: tone, tone_gain: tone_gain};
            } catch (e) {
                console.log(e);
            }
        }

        onrelease(note) {
            let group = this.oscillators[note.value];

            group.tone_gain.gain.cancelScheduledValues(0);
            this.createDecayEnvelope(
                EnvelopeVerticalInverse.vertical_exp(group.tone_gain.gain.value)
                // We invert the value because it was transformed by EnvelopeVertical.vertical_exp
            ).apply(group.tone_gain.gain,
                EnvelopeHorizontal.offset_current_time,
                EnvelopeVertical.vertical_exp);

            this.oscillators[note.value] = null;
            let toneGain = group.tone_gain;
            let tone = group.tone;
            removeNodesTimeout([toneGain, tone], this.params.release_length + 0.1);
        }

        get keyboardPlayEnabled() {
            return this.keyboard_mapping.enabled;
        }

        enableKeyboardPlay() {
            this.keyboard_mapping.enable();
        }

        disableKeyboardPlay() {
            this.keyboard_mapping.disable();
        }

        oscillatorApply(func) {
            for (let i = 0; i < 128; i++) {
                if (this.oscillators[i]) {
                    func(this.oscillators[i], i);
                }
            }
        }
    }

    function parseSclExpression(line) {
        line = line.trim().replace(/\s/g, '');

        for (let i = line.length; i > 0; i--) {
            let cut_line = line.slice(0, i);

            if (cut_line.includes(".")) { // value is in cents
                let value = parseFloat(cut_line);

                if (!isNaN(value)) {
                    return new Interval({cents: value});
                }
            } else if (cut_line.includes("/")) { // value is a ratio
                let fraction = cut_line.split("/");

                if (fraction.length === 2) {
                    let num = parseInt(fraction[0]), din = parseInt(fraction[1]);

                    if (!isNaN(num) && !isNaN(din) && num > 0 && din > 0) {
                        return new Interval(num / din);
                    }
                }
            } else { // Value is an integer
                let value = parseInt(cut_line);

                if (!isNaN(value)) {
                    return new Interval(value);
                }
            }
        }

        console.log(line);

        throw new Error(`parseSclExpression: Invalid expression ${line}`);
    }

    function sclFileToScale(file_content) {
        return parseSclFile(file_content).scale;
    }

    function parseSclFile(file_content) {
        let file_lines = file_content.split('\n');
        let description = null;
        let note_count = null;
        let notes_in = 0;

        let notes = [];

        for (let i = 0; i < file_lines.length; i++) {
            if (file_lines[i][0] === "!") {
                continue;
            }


            if (description === null) {
                description = file_lines[i];
            } else if (note_count === null) {
                try {
                    note_count = parseInt(file_lines[i]);
                } catch (e) {
                    throw new Error("sclFileToScale: second non-comment line of file should be number of notes in scale");
                }
            } else {
                if (note_count !== null) {
                    notes.push(parseSclExpression(file_lines[i]));
                    notes_in += 1;

                    if (notes_in >= note_count) {
                        break;
                    }
                }
            }
        }


        if (notes.length !== note_count) {
            throw new Error("sclFileToScale: scale size and given scale do not match in size");
        }

        return {desc: description, scale: notes};
    }

    function sclFileToPitchMapping(file_content, baseNote = KeyboardPitches.C4, baseFrequency) {
        baseFrequency = baseFrequency || new Pitch(baseNote.twelveTETFrequency());

        return pitchMappingFromScale(sclFileToScale(file_content), baseNote, baseFrequency);
    }

    class ScalaReader {
        constructor(giveScalaFile, params = {}) {
            let that = this;

            params.domElement = params.domElement || null;
            params.allowMultiple = (params.allowMultiple === undefined) ? true : params.allowMultiple;
            params.requireExtension = (params.requireExtension === undefined) ? true : params.requireExtension;
            params.onerror = params.onerror || (() => null);

            this.params = params;

            this.giveScalaFile = giveScalaFile; // arg1 -> content, arg2 -> name of file

            this.onchange = function() {
                let files = this.files;

                if (!that.params.allowMultiple && files.length > 1) {
                    that.params.onerror(new Error("Only one file allowed."));
                }

                for (let i = 0; i < files.length; i++) {
                    let file = files[i];

                    if (!file) {
                        that.params.onerror(new Error("No file selected."));
                    }

                    if (that.params.requireExtension && !file.name.endsWith(".scl")) {
                        that.params.onerror(new Error("Invalid file extension."));
                    }

                    let reader = new FileReader();
                    reader.addEventListener("loadend", function () {
                        that.giveScalaFile(reader.result, file.name);
                    });
                    reader.readAsText(file);
                }
            };

            if (params.domElement) {
                this.addTo(params.domElement);
            }
        }

        addTo(domElement) {
            if (!this.domElement) {
                domElement.addEventListener("change", this.onchange);
                this.domElement = domElement;
            }
        }

        remove() {
            this.domElement.removeEventListener("change", this.onchange);
        }
    }

    // A scale is just an array of intervals, starting on the first pitch above the unison and ending with the repeating note, usually the octave

    const Scales = {
        ET12: [
            {cents: 100},
            {cents: 200},
            {cents: 300},
            {cents: 400},
            {cents: 500},
            {cents: 600},
            {cents: 700},
            {cents: 800},
            {cents: 900},
            {cents: 1000},
            {cents: 1100},
            2/1,
        ]
    };

    for (let scaleKey in Scales) {
        let scale = Scales[scaleKey];

        for (let i = 0; i < scale.length; i++) {
            scale[i] = new Interval(scale[i]);
        }
    }

    exports.Instrument = Instrument;
    exports.masterEntryNode = masterEntryNode;
    exports.masterGainNode = masterGainNode;
    exports.masterAnalyzerNode = masterAnalyzerNode;
    exports.setMasterGain = setMasterGain;
    exports.masterMute = mute;
    exports.masterUnmute = unmute;
    exports.chainNodes = chainNodes;
    exports.contextTime = contextTime;
    exports.setTimeout = setTimeoutAudioCtx;
    exports.setTimeoutAbsolute = setTimeoutAbsoluteAudioCtx;
    exports.voidNode = voidNode;
    exports.ContextTimeout = ContextTimeout;
    exports.removeNodesTimeout = removeNodesTimeout;
    exports.Envelope = Envelope;
    exports.EnvelopeSegment = EnvelopeSegment;
    exports.EnvelopeControlPoint = EnvelopeControlPoint;
    exports.EnvelopeHorizontal = EnvelopeHorizontal;
    exports.EnvelopeHorizontalInverse = EnvelopeHorizontalInverse;
    exports.EnvelopeSamples = EnvelopeSamples;
    exports.EnvelopeVertical = EnvelopeVertical;
    exports.EnvelopeVerticalInverse = EnvelopeVerticalInverse;
    exports.noteToName = noteToName;
    exports.nameToNote = nameToNote;
    exports.KeyboardPitch = KeyboardPitch;
    exports.KeyboardInterval = KeyboardInterval;
    exports.KeyboardIntervals = KeyboardIntervals;
    exports.KeyboardPitches = KeyboardPitches;
    exports.makeKeyboardPitch = makeKeyboardPitch;
    exports.makeKeyboardInterval = makeKeyboardInterval;
    exports.KeyboardMapping = KeyboardMapping;
    exports.getDefaultKeyboardDict = getDefaultKeyboardDict;
    exports.SimpleInstrument = SimpleInstrument;
    exports.UnisonOscillator = UnisonOscillator;
    exports.Pitch = Pitch;
    exports.Interval = Interval;
    exports.makePitch = makePitch;
    exports.makeInterval = makeInterval;
    exports.TwelveTETIntervals = TwelveTETIntervals;
    exports.PitchMapping = PitchMapping;
    exports.PitchMappings = PitchMappings;
    exports.pitchMappingFromScale = pitchMappingFromScale;
    exports.Piano = Piano;
    exports.sclFileToScale = sclFileToScale;
    exports.parseSclExpression = parseSclExpression;
    exports.sclFileToPitchMapping = sclFileToPitchMapping;
    exports.ScalaReader = ScalaReader;
    exports.parseSclFile = parseSclFile;
    exports.Scales = Scales;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

    </script>
    
    <script>
        let lowpass_filter = TONES.Context.createBiquadFilter();

lowpass_filter.type = "lowpass";
lowpass_filter.frequency.setValueAtTime(2048, 0);

lowpass_filter.connect(TONES.masterEntryNode);

let instrument = new TONES.SimpleInstrument({
    unison: 8,
    detune: 20,
    blend: 0.5,
    waveform: "square"
});

instrument.connect(lowpass_filter);
instrument.enableKeyboardPlay();

let tParams = {
    scale: TONES.Scales.ET12,
    baseNote: TONES.KeyboardPitches.A4,
    baseFrequency: 440,
    unison: 8,
    detune: 20,
    blend: 0.5,
    waveform: "square",
    attack: 0.01,
    decay: 1,
    sustain: 0.2,
    release: 0.1
};

function refreshInst() {
    let keyboardPlay = instrument.keyboardPlayEnabled;

    instrument.params.unison = tParams.unison;
    instrument.detune = tParams.detune;
    instrument.blend = tParams.blend;
    instrument.waveform = tParams.waveform;

    instrument.pitch_mapping = TONES.pitchMappingFromScale(tParams.scale, tParams.baseNote, tParams.baseFrequency);

    let a = new TONES.EnvelopeSegment([0,0], [tParams.attack,1]);
    let b = new TONES.EnvelopeSegment(a.p2, [tParams.decay + tParams.attack, tParams.sustain]);
    let attack_env = new TONES.Envelope([a,b]);

    instrument.params.attack_envelope = attack_env;
    instrument.params.release_length = tParams.release;
}

let baseNoteInput = document.getElementById("base_note_input");
let baseFrequencyInput = document.getElementById("base_frequency_input");
let unisonInput = document.getElementById("unison_input");
let detuneInput = document.getElementById("detune_input");
let blendInput = document.getElementById("blend_input");

document.getElementById("sine").onclick = function() {
    tParams.waveform = "sine";
    refreshInst();
};

document.getElementById("square").onclick = function() {
    tParams.waveform = "square";
    refreshInst();
};

document.getElementById("sawtooth").onclick = function() {
    tParams.waveform = "sawtooth";
    refreshInst();
};

document.getElementById("triangle").onclick = function() {
    tParams.waveform = "triangle";
    refreshInst();
};

baseNoteInput.oninput = function(evt) {
    let value = this.value;
    try {

        tParams.baseNote = TONES.makeKeyboardPitch(value);

        baseFrequencyInput.value = tParams.baseNote.twelveTETFrequency().toFixed(5);
        tParams.baseFrequency = tParams.baseNote.twelveTETFrequency();

        refreshInst();
        this.style.backgroundColor = "#FFFFFF";

    } catch (e) {
        this.style.backgroundColor = "#FA8072";
    }
};

baseFrequencyInput.oninput = function(evt) {
    let value = this.value;

    if (value > 0) {
        tParams.baseFrequency = value;
        refreshInst();
        this.style.backgroundColor = "#FFFFFF";
    } else {
        this.style.backgroundColor = "#FA8072";
    }
};

unisonInput.oninput = function(evt) {
    tParams.unison = parseFloat(this.value);

    refreshInst();
};

detuneInput.oninput = function(evt) {
    tParams.detune = parseFloat(this.value) / 10;
    refreshInst();
};

blendInput.oninput = function(evt) {
    tParams.blend = parseFloat(this.value) / 1000;
    refreshInst();
};

baseFrequencyInput.onblur = baseNoteInput.onblur = unisonInput.onblur = function() {
    instrument.enableKeyboardPlay();
};

baseFrequencyInput.onfocus = baseNoteInput.onfocus = unisonInput.onfocus = function () {
    instrument.disableKeyboardPlay();
};

document.getElementById("lowpass_input").oninput = function() {
    let value = Math.pow(2, this.value / 100);

    lowpass_filter.frequency.value = value;
};

document.getElementById("attack_input").oninput = function() {
    let value = Math.pow(2, this.value / 400) - 1;
    tParams.attack = value;
    refreshInst();
};

document.getElementById("decay_input").oninput = function() {
    let value = Math.pow(2, this.value / 400) - 1;
    tParams.decay = value;
    refreshInst();
};

document.getElementById("sustain_input").oninput = function() {
    let value = this.value / 100;
    tParams.sustain = value;
    refreshInst();
};

document.getElementById("release_input").oninput = function() {
    let value = Math.pow(2, this.value / 400) - 1;
    tParams.release = value;
    refreshInst();
};

let reader = new TONES.ScalaReader(function(scalaFile) {
    scale = TONES.sclFileToScale(scalaFile);
    tParams.scale = scale;
    refreshInst();
}, {domElement: document.getElementById("scala_file_input")});
    </script>
<body>

</body>
</html>
