<?xml version="1.0" encoding="UTF-8" ?>
<article>
  <title>C++ Tutorial</title>
  <author>Timothy Herchen</author>

  <section>
    <title>Preface</title>
    <desc>This section tries to help you figure out whether this tutorial is right for you.</desc>

    <section>
      <title>Are you Ready?</title>

      <content>
        <p>
          <b>tl; dr</b>: I expect you to have programmed before in another,
          <vocab>imperative</vocab>
          (not
          <vocab>functional</vocab>) language. I also expect you to know the very basics of the
          <vocab>command line</vocab>
          (how to open it on your computer, and the
          <vocab>cd</vocab>
          command). Finally, I expect you to understand
          <vocab>binary</vocab>
          and
          <vocab>hexadecimal</vocab>
          notation: though you don't have to be able to read it quickly!</p>

        <p>Unfortunately, I am not good at explaining the basic ideas of programming to people. This document is written on the assumption that you have had significant experience programming in another language, preferably
          <vocab>object-oriented</vocab>
          (OO) and imperative: either a primarily scripting language like
          <vocab>JS</vocab>
          or
          <vocab>Python</vocab>, or a more heavyweight language like
          <vocab>Java</vocab>
          or
          <vocab>C#</vocab>. Though syntax and differences to other languages will be explained to the best of my ability, things like for-loops, while loops, functions, etc. which are ubiquitous in almost all such programming languages will not be explained
          beyond features and characteristics specific to C++.</p>

        <p>When discussing first languages with people who haven’t programmed before, I typically recommend a language like Python or Ruby: high-level languages that are not so “close to the metal,” but close to the way us humans think. With a little
          explanation, even a non-programmer can, perhaps with some difficulty, read basic Python code. I find that C++, on the other hand, is one of those languages whose syntax takes more getting used to.</p>

        <p>Experience solely in languages that are not imperative – like Scheme, which seems to be the most popular language in high-school and
          <link to="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">university</link>
          classes – most likely will not be helpful. I’m known to have quite the bias against Scheme in particular, so don’t take my complaints about it seriously, but functional programming requires such a different thinking paradigm than imperative
          programming that you might find some very standard implementation in imperative languages unnatural. This is not to degrade the importance and deep mathematical beauty of functional programming, but to point out that it is very different.</p>

        <p>If, before starting off on learning C++, you believe that all you need to learn is the syntax, I suggest you wait. A language may have certain syntax or "looks," but syntax is only a part of what makes a language useful, elegant, or appropriate
          for a task. Programming in C++ is very different from programming in other object-oriented languages like Java, or even deeply related languages like
          <vocab>C</vocab>. A language comes shipped not just with a different appearance, but with different conventions, structure, and thinking paradigm.</p>

        <p>As to more specific requirements, I expect you to know how to navigate folders using the
          <vocab>command line</vocab>
          on your system (i.e. knowing
          <vocab>cd</vocab>), as well as understand
          <vocab>binary</vocab>
          and
          <vocab>hexadecimal</vocab>. Both of these are relatively easy to pick up.</p>
      </content>
    </section>

    <section>
      <title>Do You Need This?</title>

      <content>
        <p>
          <b>tl; dr</b>: If you're already comfortable with all commonly-used features of C++, this is not for you, though you may find some parts of it entertaining.</p>

        <p>I’m not a professional developer by any means, just another nerdy teenager interested in programming and how computers work. I’m not trained as a teacher, either.</p>

        <p>So why am I writing this, you might ask? There is no lack of quality textbooks for C++, after all. Well, looking at online tutorials for C++, I find a few issues that really impede an interested programmer from learning the language for use. The
          vast majority of online tutorials teach C++ as either

          <list enum="number">
            <item>A small, perhaps even only syntactic extension of C</item>
            <item>A purely object-oriented language like Java, where almost every concept is represented as an object</item>
          </list>

        </p>

        <p>I think the problem with teaching these two ways of thought is not that their style is necessarily factually incorrect, per se, but that they are not taking full advantage of C++. As far as languages go, C++ is enormously complex and powerful, but
          with that complexity and power comes the power to mess up in unobvious ways. This, combined with the fact that most of these tutorials attempt to teach from the most basic grounds of programming up, makes fully teaching the language difficult. Once
          you have learned it, however, you can see the beauties of its design.</p>

        <p>I don’t know and do not profess to know all of C++’s features; this takes many years of learning and usage. I do profess, however, the understanding of how it works and how to write mediocre-quality code in it. I write this now rather than later
          because this gives me a unique perspective on the language: unlike a newbie, I’m not completely clueless, but unlike a seasoned developer, I do not explain concepts to a beginner in a way that takes an unnecessarily high-level view of a subject.
          Unfortunately, this means that this document will not be comprehensive in covering every feature of the language.</p>

        <p>If you already are an experienced C++ programmer comfortable with types and templates and
          <inl>throw</inl>
          and such things, this is not for you. In fact, you’re probably already a better programmer than I am.</p>

      </content>
    </section>

    <section>
      <title>Are You Interested?</title>
      <content>
        <p>
          <b>tl; dr</b>: C++ was designed more for high-performance situations and large codebases, not for quick and dirty scripts. If you are interested in writing highly performant programs, you might enjoy learning C++.</p>

        <p>Assuming you didn’t skip here, the fact that you read this far seems to me that you might be interested. C++ is an amazingly powerful language, an elegant combination of both low-level performance and high-level abstraction, but it takes a while
          to get used to.</p>

        <p>It is no secret that developing good code in C++ can
          <link to="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.113.1831&amp;rep=rep1&amp;type=pdf#page=6">take more time</link>
          than developing in other languages, especially scripting languages. This is because there is a lot less fluff separating you, the programmer, from the machine, your computer’s processor(s). Consequently, C++ particularly excels in situations where
          you</p>

        <list enum="lowercase">
          <item>want to maximize performance</item>
          <item>are working with small amounts of processing power and/or
            <vocab>RAM</vocab>
          </item>
          <item>work with large amounts of data</item>
        </list>

        <p>among others. If you’re just writing quick and dirty scripts to process text or something, then C++ probably isn’t for you; some people just find C++ too complex a language for their little code snippets. In large codebases or programs that need
          good performance, however, C++ can work wonders.</p>

        <p>If C++ is too complicated for you to grasp now and you’d like to try a language with similar performance benefits, you can try C, which is by and large a subset of C++, or try newer OO languages inspired by C++ like
          <link to="https://dlang.org/">D</link>
          (such a creative name) or
          <link to="https://www.rust-lang.org/en-US/">Rust</link>. C, of course, is extremely popular, but not always as scalable as C++. I know nothing about D, but it doesn’t seem that popular, probably for reasons of C++'s historicity. Though I've
          personally never really looked into it (and I probably should), from what I've seen Rust seems quite a wonderful language with performance benefits comparable to C++. It is relatively new and not yet that mature, but perhaps in the future we’ll see
          entire operating systems being written in Rust!</p>

        <p>If you’re still excited to learn C++, let’s dive in!</p>
      </content>
    </section>
  </section>

  <section>
    <title>Introduction</title>
    <desc>Here I seek to explain a few things about C++, where and why it is useful, and provide a brief writing about its history.</desc>

    <section>
      <title>What is C++?</title>

      <content>
        <p>According to its titular Wikipedia page, C++ is a general-purpose, strongly typed, compiled, object-oriented, imperative, and generic programming language. Let’s break these adjectives down one by one.</p>

        <list enum="lower">
          <item>
            <b>General-purpose</b>: C++ is meant for a wide variety of uses. You’ll see C++ code being used in a variety of places, from spaceships to video games to common desktop applications.</item>
          <item>
            <b>Strongly typed</b>: Unlike Python and JS, but like Java, C and C#, every variable has a
            <vocab>type</vocab>. This type is set and cannot be later changed.</item>
          <item>
            <b>Compiled</b>: A computer is not that smart; it’s just extremely fast. C++ code, which a programmer can read (<link to="http://ioccc.org/">hopefully</link>
            :P), is translated by a compiler into
            <vocab>machine code</vocab>. This contrasts with a language like Python, Java or C# in which the code is, to some degree, interpreted: where another native-level program reads the code, figures out what to do, and then executes it on the processor.
            Because of this intermediate step, well-written C++ code is inherently faster than the equivalent
            <i>interpreted</i>
            Python and Java code, with few exceptions. I know Java can be compiled as well, so please don't hate on me for saying this.</item>
          <item>
            <b>Object-Oriented</b>: C++ features classes, user-defined objects that can be used and manipulated in definable ways. As such, code to solve a problem is written using these objects.</item>
          <item>
            <b>Imperative</b>: C++’s structure is based on statements that are compiled and executed in the sequence specified in the program. It is not a functional language, but it does contain some features similar to and inspired from those of functional languages.</item>
          <item>
            <b>Generic</b>: Probably the most difficult to describe to someone who hasn’t programmed using generics, but the concept of generic programming is code you write is, to some degree, "agnostic" about types. In other words, the code you write can be
            used for any number of types; in any given instance you just have to tell it which one to use.</item>
        </list>

        <p>C++ is only a
          <link to="https://isocpp.org/std/the-standard">language definition</link>
          and there exist a number of compilers working on various systems. C++ compilers exist for Windows, macOS, all flavors of Linux, OpenBSD, et cetera.</p>
      </content>
    </section>

    <section>
      <title>Why C++?</title>
      <desc>C++ is personally my favorite language, simply because of its power and ease of use for performance-critical applications. Since I do a lot of numerically intensive computing, this is often relevant. As I talked about in the
        <ref to="Preface">preface</ref>, C++ is best suited for maximizing performance, writing programs for resource-constrained systems, or working with large amounts of data. There are some applications where it is not necessary, but other places where it is very appropriate.</desc>

      <section>
        <title>Why not C?</title>

        <content>
          <p>C is a wonderful language, and there are some systems where it is definitely better to use than C++. Even though C++ is not inherently slower than C like
            <vocab>interpreted</vocab>
            languages are, keeping C++’s speed at par with C in practice necessitates restricting some of C++’s language features: not all, but some. These features are those that cannot be implemented by the compiler without some significant overhead. As such,
            C is often the language of choice for small systems.</p>

          <p>C’s concepts, however, are almost completely low-level. This is not a bad thing, but can make programming higher-level libraries more difficult. C++ has the low-level capabilities of C, but combines it with higher-level ideas, such as classes and
            templates and so forth. While this may have some (usually small) overhead, expressing yourself in C++, especially when solving a complex problem or writing in large codebases, is usually easier than expressing yourself in C. Furthermore, it’s harder
            to mess up something critical in C++, because
            <vocab alias="compiler">compilers</vocab>
            can do stricter compile-time checking and warn you of possible errors.
          </p>

        </content>
      </section>

      <section>
        <title>Why not Java?</title>

        <content>
          <p>Java is also a wonderful language. It certainly separates you more from the machine than C++ does, which can be good or bad. It is also significantly more portable than C and C++ across operating systems (though C++11’s std::thread and C++17’s
            std::filesystem seeks to change some of that). Most people find that developing in Java is faster, safer, and easier than in C++. There is a reason, after all, that it is the most popular language for development.</p>

          <p>Using Java has some performance costs, though. The usage of the
            <vocab>Java Virtual Machine</vocab>
            (JVM), which adds an intermediate layer, means that there is an inherent performance loss. Memory usage is also much higher than equivalent native-level programs. Accessing memory can be slow, and there is no concept of
            <vocab alias="pointer">pointers</vocab>
            like in C or C++, making certain algorithms much slower than their C/C++ counterparts. If you need to write code with native speed to be used in Java programs, you need to use interfaces like the Java Native Interface (JNI). I was attempting to use
            this, in fact, for our robotics team, but found it incredibly difficult to use. Furthermore, simply using the JNI incurs performance issues during transfer of control between JVM and JNI. Java is also quite verbose compared to most other languages.
            Personally, I wish they would add operator overloading to the language, but perhaps that is a silly idea.</p>

          <p>Also, unlike many other languages, the Java language is inherently tied to a corporation: formerly Sun Microsystems, now Oracle. While I promise not to go berserk with "free software! free software!", this does mean that the language and reference
            implementation (i.e.
            <link to="https://en.wikipedia.org/wiki/HotSpot">HotSpot</link>, which is in C++ by the way :P) is written by a company. Thankfully, through a community process and different licensing, many of these issues have been remedied. Unfortunately, Oracle's famous
            <link to="https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.">lawsuit</link>
            against Google seems to go against this premise.</p>

          <p>Unfortunately, I have quite a bitter relationship with Java, probably from various bad experiences involving it but not because of a fault of the language itself, so take my words about it with a handful or two of salt.</p>

        </content>
      </section>

      <section>
        <title>Why not Python?</title>
        <content>
          <p>Python is probably my second favorite language after C++. It is excellent for short scripts, but also great for larger projects that need to be developed quickly. Python also provides lovely object-oriented features -- and operator overloading! It
            is incredibly versatile, and contains a staggering number of built-in standard libraries which do everything from request website data to compression. Plus, it links with native-level code incredibly well.</p>

          <p>Python, unfortunately, compared to Java and C/C++, is quite slow. It is fine for many uses, but when building performance-critical applications, it is probably not your best choice. If you’re interested in speeding up your Python code without any
            extra work, however, check out
            <link to="http://pypy.org/">PyPy</link>.</p>
        </content>
      </section>

      <section>
        <title>Why not C++?</title>
        <content>
          <p>Every language has problems, and C++ is no exception. It is one of the most complex languages still in common use, which means that messy style is quite common. In practice, restrictions are often placed on what features of C++ are to be used
            among a group of developers, in the form of a style guide, so their code is more maintainable. After all, with great power comes great responsibility.</p>

          <p>C++ is not easy to learn, and even experienced developers will occasionally have issues, especially regarding the Standard Template Library (STL).
            <link to="stackoverflow.com">Stack Overflow</link>, however, exists for a reason!</p>

          <p>If you’re attempting to find an error in a larger program, you might have a hard time if it’s not found at compile-time. In the worst case scenario you just get a
            <vocab>segmentation fault</vocab>
            or some other, more obscure error, and have no clue where it came from. Thankfully, tools like
            <link to="http://valgrind.org/">Valgrind</link>
            and
            <link to="https://www.gnu.org/software/gdb/">gdb</link>
            exist to help you.</p>

          <p>I hope these problems don’t discourage you, however, on your C++ journey!</p>
        </content>
      </section>
    </section>

    <section>
      <title>Where is C++?</title>

      <content>
        <p>C++ code is found in many places. Large and important libraries which require fast performance, such as
          <link to="https://github.com/opencv/opencv">OpenCV</link>
          and
          <link to="https://github.com/tensorflow/tensorflow">TensorFlow</link>, often use C++. The
          <link to="https://github.com/bitcoin/bitcoin">Bitcoin</link>
          blockchain system is implemented in C++, as well as
          <link to="https://github.com/v8/v8">Google Chrome</link>
          and
          <link to="https://github.com/Microsoft/ChakraCore">Microsoft Edge</link>. NASA
          <link to="https://ntrs.nasa.gov/search.jsp?R=20080039927">uses C++</link>
          for many of their spacecraft. As you can see, it is used in places where performance and reliability are imperative.</p>

        <p>Some people seem to think C++ is a dying language, or that it is obsolete. Perhaps it's because it's quite old, so it's not considered that "cool" to know it anymore. It's true that nowadays computers are much faster, and often a quickly whipped
          up Python program will work for a certain task which 10 years ago would require a lot more optimization. But the computer power growth rates
          <link to="https://en.wikipedia.org/wiki/Moore%27s_law#Near-term_limits">are slowing</link>, and programmers must take advantage of the growth of the number of cores in a processor. Python, unfortunately, suffers from the
          <link to="https://en.wikipedia.org/wiki/Global_interpreter_lock">Global Interpreter Lock</link>
          (GIL) which makes
          <vocab>multithreading</vocab>
          much more difficult. Threading used to be a similarly sore spot for C++, as it had no built-in thread concept like Java does, but C++11 brought with it std::thread, a standardized threading system portable across all supported computers. There also
          exist portable frameworks like
          <link to="http://www.openmp.org/">OpenMP</link>
          and
          <link to="https://www.khronos.org/opencl/">OpenCL</link>
          that allow C or C++ programmers to take advantage of multiple cores and/or multiple
          <vocab>GPU</vocab>s with easier code. Java interfaces to these frameworks are currently lacking in performance.</p>

        <p>In terms of popularity (which I personally think is a poor index), C++ is consistently
          <link to="https://www.tiobe.com/tiobe-index/">surveyed</link>
          to be in the top ten most popular languages among developers.</p>

      </content>
    </section>

    <section>
      <title>How was C++ invented?</title>

      <content>

        <p>C++ was invented by Danish computer scientist and programmer
          <link to="https://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</link>
          in 1979. He applied the concept of classes, inspired by
          <link to="https://en.wikipedia.org/wiki/Simula">Simula</link>, to the already extant C. Throughout the years, C++ developed as a language and was eventually standardized by
          <vocab>ISO</vocab>
          in 1998. A committee of representatives from various companies in the programming industry, as well as some independent members, continually work on the language definition, expanding it and taking suggestions from the public. Every five years or so
          ISO ratifies a new standard. After the initial standardization, there have been four official standards: C++03, C++11, C++14, and C++17. All of these add new features from the language, some much more significant than others. Small errors or
          mis-features are occasionally removed, but conservatively so as to maintain backwards-compatibility. Given this committee process, C++ is not owned in whole or in part by any company or person.</p>

        <p>For more information on the history of C++, you can peruse through Stroustrup’s
          <link to="http://stroustrup.com">personal website</link>
          or the
          <link to="https://en.wikipedia.org/wiki/C%2B%2B#History">Wikipedia page</link>.</p>
      </content>

    </section>
  </section>

  <section>
    <title>The Basics</title>

    <section>
      <title>Setting Up a C++ Environment</title>

      <content>
        <p>Before you start learning C++, you need to have an environment. For this tutorial you’ll need to have a C++
          <vocab>compiler</vocab>, preferably one that can handle C++11 and a text editor. The most reputable C++ compilers are probably
          <link to="https://clang.llvm.org/">Clang</link>,
          <link to="https://gcc.gnu.org/projects/cxx-status.html">GCC</link>, and the
          <link to="https://software.intel.com/en-us/c-compilers">Intel compiler</link>. A text editor that’s not Notepad or TextEdit or whatever is quite important; syntax highlighting is strongly recommended. For free text editors, you can try
          <link to="https://code.visualstudio.com/">Visual Studio</link>,
          <link to="https://www.eclipse.org/">Eclipse</link>,
          <link to="https://notepad-plus-plus.org/">Notepad++</link>
          (Windows-only),
          <link to="https://atom.io/">Atom</link>, or
          <link to="https://www.gnu.org/software/emacs/">Emacs</link>. If you’re into it, you can try
          <link to="http://www.vim.org/">Vim</link>, but for some people that might be harder than C++ itself....</p>

        <p>For this tutorial, I also suggest you install GNU Make.</p>

        <p>As stated in Are You Ready?, you will need a basic understanding of the command line on your computer. This is Terminal on macOS, and Command Prompt on Windows. I suggest you learn the
          <vocab>cd</vocab>
          command, as well as
          <vocab>ls</vocab>
          (<vocab>dir</vocab>
          on Windows).</p>
      </content>

      <section>
        <title>macOS</title>

        <content>
          <p>XCode command-line tools come with the Clang compiler, as well as GNU Make. In Terminal, enter in the following command:</p>

          <code lang="none">xcode-select --install</code>

          <p>This will install XCode's tools. You may have already done this, considering it also contains important development tools such as Git, Subversion, etc. To test out your Clang installation, try running the command
            <inl lang="none">g++ -v</inl>
            in Terminal. It should print out something along the lines of:</p>

          <code lang="none">
            <include file="snippets/clang_version_output.txt"/>
          </code>

          <p>If you don’t like Clang for some reason you can get GCC installation instructions
            <link to="https://gcc.gnu.org/install/">here</link>.</p>

          <p>To check your make installation you can run
            <inl lang="none">make –v</inl>
            which should print out something like:</p>

          <code lang="none">
            <include file="snippets/gnu_make_version_output.txt"/>
          </code>
        </content>
      </section>

      <section>
        <title>Microsoft Windows</title>

        <content>
          <p>Unfortunately, it is somewhat of a hassle to install a C++ compiler on Windows. For GCC, you need to install a GNU development interface to Windows like MinGW.
            <link to="http://preshing.com/20141108/how-to-install-the-latest-gcc-on-windows/">This website</link>
            provides a good tutorial to do this. Don’t fret! You only have to do this once; or you could switch to Unix. ;) You can check your installation with
            <inl lang="none">g++ -v</inl>.</p>

          <p>Installing GNU Make is similarly done through MinGW. You can check your installation with
            <inl lang="none">make -v</inl>.</p>
        </content>
      </section>

      <section>
        <title>Linux</title>

        <content>
          <p>First, test whether GCC is already installed with
            <inl lang="none">g++ -v</inl>. If not, to install GCC on Linux you can run:</p>

          <code lang="none">
            sudo apt-get install gcc
          </code>

          <p>Note that you will likely have to enter in your password for the installation to work. You can check your installation with
            <inl lang="none">g++ -v</inl>.</p>

          <p>Check if GNU Make is already installed with
            <inl lang="none">make –v</inl>. To install make, run:</p>

          <code lang="none">
            sudo apt-get install make
          </code>

          <p>You can check your installation with
            <inl lang="none">make -v</inl>.</p>
        </content>
      </section>
    </section>

    <section>
      <title>Hello, World! Example</title>

      <content>
        Let's try a basic hello world program.
      </content>

      <section>
        <title>The Program</title>

        <content>
          <p>In your text editor, type in or copy-paste the following code:</p>

          <code>
            <include file="snippets/hello_world.cc"/>
          </code>

          <p>Save this to a file, say,
            <code lang="none">hello.cc</code>. Go to the command line, navigate to the directory containing
            <code lang="none">hello.cc</code>
            and run the following command:</p>

          <code lang="none">g++ -o hello hello.cc</code>

          <p>Note that g++ is simply an alias for the C++ compiler. This should create an
            <vocab alias="executable">executable file</vocab>
            called
            <inl lang="none">hello</inl>
            in the same folder.</p>

          <figure>
            <image file="images/executable_illustration_1.png"/>

            <figcaption>The executable and the source file, chilling out.</figcaption>
          </figure>

          <p>You can either open it normally (in Finder, Windows Explorer, etc.) or run it from the command line by running <inl lang="none">./hello</inl>. Either way, you should get something like this:</p>

          <figure>
            <image file="images/hello_world_output1.png"/>

            <figcaption>The result of executing the <code lang="none">hello</code> executable.</figcaption>
          </figure>

<p>As you can see, the executable ran and something rather boring happened: "Hello, World!" was printed to the console. All that manure for what in Python 2 we could have done as just print "Hello, World!"? Man!</p>

<tab-system>
<tab title="C++">
  <code>
  <include file="snippets/hello_world/prog.cc" />
</code>
</tab>
<tab title="Python 2">
  <code lang="python">
  <include file="snippets/hello_world/prog.py2" />
</code>
</tab>
<tab title="Python 3">
  <code lang="python">
  <include file="snippets/hello_world/prog.py3" />
</code>
</tab>
<tab title="Java">
  <code lang="java">
  <include file="snippets/hello_world/prog.java" />
</code>
</tab>
<tab title="JS">
  <code lang="javascript">
  <include file="snippets/hello_world/prog.js" />
</code>
</tab>
</tab-system>

</content>
</section>

<section>
  <title>How it Works</title>

<content>

  <p>Let's dissect this and figure out precisely what is going on here. First, let's discuss the C++ code.</p>

<p>Loosely, the first line <inl>#include &lt;iostream&gt;</inl> tells the C++ compiler that we want the source code of the file "iostream" to be inserted here. The preprocessor sees this instruction, called a preprocessing directive, and just replaces it with the contents of "iostream." Note that we call this preprocessing because all this happens before the code is actually examined for errors and syntax and such.</p>

<p>Where is this magical iostream file coming from? Well, iostream is part of the C++ Standard Library, a C++ library shipped with all standards-compliant compilers. It's designed to make programming a lot easier for us developers by providing efficient and/or elegant implementations for common tasks.</p>

<p>To see what the code looks like after preprocessing, you can run the command:</p>

<code lang="none">g++ -E hello.cc</code>

<p>The <inl lang="none">–E</inl> compiler flag tells it to stop compiling and spit out the result of the preprocessor to the console. But brace yourself, because iostream is a pretty large file. iostream also <inl>#include</inl>s other files. On my laptop, the result of the preprocessor is 39074 lines long!</p>

<p>Thankfully, you don't have to understand its contents. I don't understand it, either. What iostream does, however, is define (among other things) an object called <inl>std::cout</inl>. This object can be given things to write to the console.</p>

<p>In the naming hierarchy, where does this object live, you might ask? Well, it lives in the namespace, or group of names, "std" (for standard, not for...) and is called cout. I like to think of namespaces as folders. If you keep things in folders all nicely organized, it's harder to accidentally reference a file with the same name, but in different locations. In the same way we keep our variables and functions in namespaces so they don't get mixed up.</p>

<p>The third line defines a function. This function, like any other function in C++ and other strongly typed languages like Java or C, has a return type, specifying what type of value it is returning. In this case, the return type is "int." An int is a representation of an integer. The function's name is "main," and it takes no arguments. The body of the function is enclosed in curly braces.</p>

<p>"main" is no ordinary function. Whatever is in it will be what is actually run when you execute a program. This is very similar to main in a Java class (or Main in C#), as well as main in C and <inl lang="python">if __name__ == "__main__"</inl> in Python. If we called our function "main1" instead, nothing will actually be run.</p>

<p>At the end of third line is a comment. Like Java, C#, and JS a line comment in C++ begins with two forward slashes and ends at the end of the line. Note that forward slashes in strings do not start comments.</p>

<p>We can also write block comments. A block comment is a comment that can span one or multiple lines, starting at /* and ending at */, just like Java, C#, and JS. Note that these block comments do not nest! They can be put anywhere you'd like, including in the middle of statements (but I don't recommend it).</p>

<tab-system>
<tab title="C++">
  <code>
  <include file="snippets/comments_demonstration/prog.cc" />
</code>
</tab>
<tab title="Python">
  <code lang="python">
  <include file="snippets/comments_demonstration/prog.py" />
</code>
</tab>
<tab title="Java">
  <code lang="java">
  <include file="snippets/comments_demonstration/prog.cc" />
</code>
</tab>
<tab title="JS">
  <code lang="javascript">
  <include file="snippets/comments_demonstration/prog.cc" />
</code>
</tab>
</tab-system>

<p>The fourth line is probably the strangest line of the program to foreigners. What <inl>&lt;&lt;</inl> is doing is streaming the string "Hello, World\n" to <inl>std::cout</inl>. I think of it like you are pouring out the string. This syntax contrasts with a lot of other languages' console output methods, such as Java's <inl lang="java">System.out.println</inl>, Python's <inl lang="python">print</inl>, C's <inl lang="c">printf</inl> and JS's <inl lang="javascript">console.log</inl>, all of which are framed as a function.</p>

<p>To be more precise, <inl>&lt;&lt;</inl> is a binary operator (an operator taking two arguments), which passes the string to <inl>std::cout</inl> for <inl>std::cout</inl> to handle. Furthermore, this operator returns <inl>std::cout</inl> again, and since operators are evaluated from left to right, we can do something like:</p>

<code>
  <include file="snippets/merry_christmas_orig.cc" />
</code>

<p>and it will write out "Merry Christmas to you!", because it is evaluated as</p>

<code>
  <include file="snippets/merry_christmas_parsed_as.cc" />
</code>

<p>The fourth line ends in a semicolon. Just like C, Java, C# and JS, a semicolon is the only statement separator in C++. (Somewhat little known fact: a semicolon is also a valid statement separator in Python.)</p>

<p>You might notice that the function main has no return statement. Normally, if main returns 0, it signifies the program ran without errors; another value (often -1) signifies an error occurred. The C++ standard declares that if the end of main is reached, the function implicitly returns 0. Convenient!</p>

<p>Well now that we understand (hopefully) what the code does, how does the computer?</p>
</content>
</section>

<section>
<title>The Compiler</title>

<content>
<p>The workings of a compiler are wonderful but mysterious. Personally, I have no clue how they work, so I treat them as sort of a black box. I feed my laboriously written source code into and blithely watch as worthless assembly comes out ("garbage in, garbage out").</p>

<p>Jokes aside, a compiler is the heart and soul of a C++ environment. Without it, the computer has no idea what you want it to do. Fundamentally, the compiler, given source code, converts the code to assembly. Assembly is not exactly a single language, but rather a class of language that maps extremely closely to what the computer's CPU can do. If you want to see the assembly output of a C++ program, compile like so:</p>

<code lang="none">g++ -S hello.cc</code>

<p>This will write the assembly output of the compiler to a file called <code lang="none">hello.s</code>.</p>

<p>The file's content looks really complicated, but every operation is extremely simple. Move this chunk of memory here, do this operation here; it's very basic, so basic that a programmer cannot really represent high-level concepts in it. It makes me slightly sick to think that people used to have to write large programs in this. Thankfully, most people don't have to experience writing assembly anymore.</p>

<p>We're not done yet, though, but we're close. The computer must convert the assembly into machine code. Machine code simply consists of a long hexadecimal sequence telling the <vocab>CPU</vocab> exactly what to do and is completely unreadable to the common human. The conversion from assembly to machine code is not done by the compiler itself, but by a vendor-provided <vocab>assembler</vocab>.</p>

<p>Thankfully, we don't need to handle the assembly intermediate step. Without <inl lang="none">–S</inl>, the compiler will just output machine code that we can use immediately.</p>

<p>Well that was long. I sincerely hope you haven't seen a hello world example/explanation that long before. Perhaps it was excessive, but I wanted to show you exactly what is going on so you don't get confused later when I talk about compiling, and also get you to appreciate how much fluff languages like Python abstract away for you. I won't even go close to this much into detail in the future, but a lot of people seem to get confused about the role of a compiler and how to even compile and execute a C++ file, so I thought this would be helpful for uninformed individuals. I'm sure some or maybe even most of it was redundant information to you.</p>

<p>If you want to play around with this example, you can download it <link to="examples/example1.zip" download="">here</link>. To compile <code lang="none">hello.cc</code>, just run <inl lang="none">make</inl>. To output assembly to <code lang="none">hello.s</code>, run <inl lang="none">make asm</inl>. Finally, to print out preprocessor output, do <inl lang="none">make pre</inl>. Enjoy!</p>
        </content>
      </section>

      <section>

        <title>Summary</title>

        <content>
<p>We've just looked at a very basic program. You've learned the role of the function main (the function that’s actually run) as well as learned what printing looks like.</p>

<p>C++ is a compiled language. Thus, its source code is turned into machine code by a <vocab>compiler</vocab> and <vocab>assembler</vocab>. To compile your program, run in a shell:</p>

<code lang="none">g++ -o &lt;machine code output file name&gt; &lt;path to source&gt;</code>

<p>For example, to compile udder.cc to milk, we do:</p>

<code lang="none">g++ -o milk udder.cc</code>

<p>As an aside, I suggest you compile to <code lang="none">milk.exe</code> on Windows.</p>

<p>We can run <code lang="none">milk</code>/<code lang="none">milk.exe</code> in the command line by doing <inl lang="none">./milk</inl>. We can also open it as you would normally open a file in the system file viewer (Explorer, Finder, etc.), which should open up a command line interface and run the program immediately.</p>
</content>
</section>
    </section>
  </section>
</article>
