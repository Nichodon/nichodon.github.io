import xml.etree.ElementTree
import hashlib

document_header = """<!DOCTYPE html>
<!-- This document was generated by parse_article.py at moomath.com/files/article_parser/parse_article.py -->

<html lang="en">

<head>
<meta charset="utf-8">
<title>%s</title>
<link rel="stylesheet" type="text/css" href="https://moomath.com/styles.css">
<link rel="icon" href="https://moomath.com/images/favicon.png" sizes="16x16" type="image/png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<style>
.sidebar {
position: fixed;
left: 0;
z-index: 10;
overflow-y: auto;
top: 20;
}
</style>

<br>
<br>
<div id="top"></div>

<div class="container" id="container">
<div class="sidebar" id="sidebar">
    <h3>Table of Contents</h3>
    %s
</div>

<div class="content" id="content">
<div class="article">
"""

document_ending = """

</div>
</div>
</div>

<br>
<br>
<div id="bottom"></div>

<script src="https://moomath.com/frame.js"></script>
<script>
function clickFactory(id) {return Function("evt","evt.stopPropagation();window.location.hash = '" + id + "';")}
k = document.getElementsByClassName('t-elem');for (var i = 0; i < k.length; i++) {var j = k[i].id; k[i].addEventListener('click', clickFactory(j))}
</script>

</body>
</html>

<!-- This document was generated by parse_article.py at moomath.com/files/article_parser/parse_article.py -->
"""

def hashID(idf):
    idhasher = hashlib.new('ripemd160')
    idhasher.update(idf)
    return idhasher.hexdigest()

class ArticleReader:
    def __init__(self, file_name = None):
        self.file_name = file_name
        self.root_node = None

    def set_file(self, file_name):
        self.file_name = file_name

    def readXML(self):
        if self.file_name:
            self.tree = xml.etree.ElementTree.parse(self.file_name)
            self.root_node = self.tree.getroot()
        else:
            raise AttributeError("A file name was not given")

def XMLtostr(node):
    return xml.etree.ElementTree.tostring(node)

def pathDepth(path):
    return path.count('.') + 1

def generatePathHeader(path, title):
    depth = pathDepth(path)

    return "<h%s id='%s'>%s: %s</h%s>\n" % (depth, hashID(path), path, title.text, depth)

def contentToHTML(node):
    if node.tag == 'desc':
        return '<p>%s</p>' % node.text
    elif node.tag == 'content':
        return XMLtostr(node)
    elif node.tag == 'title':
        return '<p>%s</p>' % node.text

class Section:
    def __init__(self, desc, title, content, children):
        self.desc = desc
        self.title = title
        self.content = content
        self.children = children

        self.ref = -1
        self.fullref = ""

    def isLeaf(self):
        return self.children is not None

    def hasContent(self):
        return self.content is not None

    def hasTitle(self):
        return self.title is not None

    def hasDesc(self):
        return self.desc is not None

    def hasChildren(self):
        return self.children is not None

    def gTitle(self):
        if self.hasTitle():
            return XMLtostr(self.title)

    def tTitle(self):
        if self.hasTitle():
            return self.title.text

    def gDesc(self):
        if self.hasDesc():
            return XMLtostr(self.desc)

    def gXMLContent(self):
        if self.hasContent():
            return XMLtostr(self.content)

    def __str__(self):
        return "Title: %s\nDesc: %s\n\nContent: %s\n\nChildren:\n%s" % (self.gTitle(), self.gDesc(), self.gXMLContent(), (';\n'.join(str(child) for child in self.children) if self.children else None))

    def __repr__(self):
        return self.__str__()

    def setSectionIndex(self, i, recursive = True):
        self.ref = i

        if recursive and self.hasChildren():
            for n_i, child in enumerate(self.children):
                child.setSectionIndex(n_i)

    def setSectionFullRef(self, i, recursive = True):
        self.fullref = i
        if recursive and self.hasChildren():
            for n_i, child in enumerate(self.children):
                child.setSectionFullRef("%s.%s" % (i, n_i))

    def getPathByTitle(self, name):
        if self.hasTitle():
            if self.tTitle().replace(' ', '').lower() == name:
                return ''

            if self.hasChildren():
                for n_i, child in enumerate(self.children):
                    result = child.getPathByTitle(name)

                    if result is not None:
                        return '%s.%s' % (n_i, result)

    def toHTML(self):
        header = generatePathHeader(self.fullref, self.title)
        cntf = childC = None

        if self.hasDesc():
            cntf = contentToHTML(self.desc)
        elif self.hasContent():
            cntf = contentToHTML(self.content)

        if self.hasChildren():
            childC = '\n\n'.join(child.toHTML() for child in self.children)

        return header + (cntf if cntf else '') + (childC if childC else '')

    def generateSectionTree(self):
        if self.hasChildren():
            header = "<b>%s</b>:\n%s\n<ul>"
            footer = "</ul>"
            return header % (self.fullref, self.title.text) + "\n".join("""<li class="t-elem" id="%s">%s</li>""" % (hashID(s.fullref), s.generateSectionTree()) for s in self.children)
        else:
            return '%s' % ("<b>%s</b>: %s" % (self.fullref, self.title.text))



def extractTitleNode(node):
    index = 0
    title_result = None

    for title in node.findall("title"):
        if index > 0:
            print "Warning: more than one title found"

        title_result = title
        index += 1

    return title_result

def extractDescNode(node):
    index = 0
    desc_result = None

    for desc in node.findall("desc"):
        if index > 0:
            print "Warning: more than one description found"

        desc_result = desc
        index += 1

    for desc in node.findall("description"):
        if index > 0:
            print "Warning: more than one description found"

        desc_result = desc
        index += 1

    return desc_result

def extractContentNode(node):
    index = 0
    content_result = None

    for content in node.findall("content"):
        if index > 0:
            print "Warning: more than one content element found"

        content_result = content
        index += 1

    return content_result

def XMLSectiontoSection(node):
    children_list = []

    for s in node.findall("section"):
        children_list.append(XMLSectiontoSection(s))

    return Section(extractDescNode(node), extractTitleNode(node), extractContentNode(node), children_list if children_list else None)

def writeHeaders(file_obj, title = "Article", sect_tree = ""):
    file_obj.write(document_header % (title, sect_tree))

def writeEndings(file_obj):
    file_obj.write(document_ending)

class Article:
    def __init__(self, root_node):
        self.top_sections = []
        self.section_dict = {}

        self.root_node = root_node

    def parseSections(self):
        sectionlist = self.root_node.findall("section")
        self.top_sections = [XMLSectiontoSection(s) for s in sectionlist]

    def numberSections(self):
        for i, section in enumerate(self.top_sections):
            section.setSectionIndex(i, True)
            section.setSectionFullRef(str(i), True)

    def getPathByTitle(self, name):
        name = name.replace(' ', '').lower()

        for i, section in enumerate(self.top_sections):
            result = section.getPathByTitle(name)
            if result:
                return '%s.%s' % (i, result.rstrip('.'))

    def generateSectionTree(self):
        header = """<ul class="tree">"""
        footer = """</ul> <!-- end tree -->"""

        contentf = '\n'.join("""<li class="t-elem" id="%s">%s</li>""" % (hashID(i), s.generateSectionTree()) for i,s in enumerate(self.top_sections))

        self.section_tree = header + contentf + footer

    def flatten(self):
        for section in self.top_sections:
            yield section.toHTML()

    def writeContents(self, file_obj):
        [file_obj.write(line + '\n') for line in self.flatten()]

    def writeTo(self, filef):
        with open(filef, 'w') as file_obj:
            writeHeaders(file_obj, "C++ Article", self.section_tree)

            self.writeContents(file_obj)

            writeEndings(file_obj)

    def root(self):
        return self.root_node

    def __str__(self):
        return XMLtostr(self.root_node)

    def __repr__(self):
        return self.__str__()

if __name__ == "__main__":
    file_name = "test_article.xml"
    output_name = "test_output.html"

    article_reader = ArticleReader(file_name)

    print "Reading and parsing XML..."
    article_reader.readXML()
    print "Parsed XML."

    article = Article(article_reader.root_node)
    article.parseSections()
    article.numberSections()
    article.generateSectionTree()

    article.writeTo(output_name)
