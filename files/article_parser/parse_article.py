import xml.etree.ElementTree
import hashlib
import parse_content
import codecs

from string import ascii_lowercase
import itertools

document_header = """<!DOCTYPE html>
<!-- This document was generated by parse_article.py at moomath.com/files/article_parser/parse_article.py -->

<html lang="en">

<head>
<meta charset="utf-8">
<title>%s</title>
<link rel="stylesheet" type="text/css" href="https://moomath.com/styles.css">
<link rel="stylesheet" type="text/css" href="article.css">
<link rel="icon" href="https://moomath.com/images/favicon.png" sizes="16x16" type="image/png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<style>
.sidebar {
position: fixed;
left: 0;
z-index: 10;
overflow-y: auto;
top: 20;
}
</style>

<br>
<br>
<div id="top"></div>

<script>
var inSidebar = false;
var lastPXTime = Date.now();
var delay = 200;
function lpF() {
  if (inSidebar) {
    if (mX < window.innerWidth / 4) {
      lastPXTime = Date.now();
    }

    if (Date.now() > lastPXTime + 200) {
      inSidebar = false;
      var cN = document.getElementById("sidebar").className;
      document.getElementById("sidebar").className = cN.replace(" use", "").replace("use", "")
      lastPXTime = Date.now();
    }
  } else {
    if (mX < window.innerWidth / 10 && mY > window.innerHeight / 4) {
      if (Date.now() > lastPXTime + 200) {
        inSidebar = true;
        document.getElementById("sidebar").className += " use";
        lastPXTime = Date.now();
      }
    } else {
      lastPXTime = Date.now();
    }
  }
}

var mX = 1000, mY = 0;

function mPL(e) {
mX = e.clientX;
mY = e.clientY;
}

document.addEventListener("mousemove", mPL);
setInterval(lpF, 20);
</script>

<div class="container" id="container">
<div class="sidebar" id="sidebar">
    <h3>Table of Contents</h3>
    %s
</div>

<div class="content-c" id="content-c">
<div class="article">
<br>
<br>
"""

document_ending = """

</div>
<br>
<br>
<div id="bottom"></div>
</div>
</div>

<br>
<br>

<script src="https://moomath.com/frame.js"></script>
<script>
function clickFactory(id) {return Function("evt","evt.stopPropagation();window.location.hash = '" + id + "';")}
k = document.getElementsByClassName('t-elem');for (var i = 0; i < k.length; i++) {var j = k[i].attributes.udderref.value; k[i].addEventListener('click', clickFactory(j))}
</script>

</body>
</html>

<!-- This document was generated by parse_article.py at moomath.com/files/article_parser/parse_article.py -->
"""

header_height = "80px"

def iter_all_strings():
    size = 1
    while True:
        for s in itertools.product(ascii_lowercase, repeat=size):
            yield "".join(s)
        size += 1

idfdict = {}
nf_l = iter_all_strings()

def hashID(idf):
    if idf in idfdict:
        return idfdict[idf]

    idfdict[idf] = nf_l.next()
    return idfdict[idf]

def hashLoc(idf):
    return "#" + hashID(idf)

class ArticleReader:
    def __init__(self, file_name = None):
        self.file_name = file_name
        self.root_node = None

    def set_file(self, file_name):
        self.file_name = file_name

    def readXML(self):
        if self.file_name:
            self.tree = xml.etree.ElementTree.parse(self.file_name)
            self.root_node = self.tree.getroot()
        else:
            raise AttributeError("A file name was not given")

def XMLtostr(node):
    return xml.etree.ElementTree.tostring(node)

def pathDepth(path):
    return path.count('.') + 1

def generatePathHeader(path, title):
    depth = pathDepth(path)

    return """<h%s id='%s' style="padding-top: %s; margin-top: -%s;">%s: %s</h%s>\n""" % (depth, hashID(path), header_height, header_height, path, title.text, depth, )

def contentToHTML(node, article):
    if node.tag == 'desc':
        return """<div class="content"><p>%s</p></div>""" % node.text
    elif node.tag == 'content':
        return parse_content.parse(node, article)
    elif node.tag == 'title':
        return '<p>%s</p>' % node.text

class Section:
    def __init__(self, desc, title, content, children):
        self.desc = desc
        self.title = title
        self.content = content
        self.children = children

        self.ref = -1
        self.fullref = ""
        self.parent = None

    def isLeaf(self):
        return self.children is not None

    def hasContent(self):
        return self.content is not None

    def hasTitle(self):
        return self.title is not None

    def hasDesc(self):
        return self.desc is not None

    def hasChildren(self):
        return self.children is not None

    def gTitle(self):
        if self.hasTitle():
            return XMLtostr(self.title)

    def tTitle(self):
        if self.hasTitle():
            return self.title.text

    def gDesc(self):
        if self.hasDesc():
            return XMLtostr(self.desc)

    def gXMLContent(self):
        if self.hasContent():
            return XMLtostr(self.content)

    def setParent(self, parent):
        self.parent = parent

    def __str__(self):
        return "Title: %s\nDesc: %s\n\nContent: %s\n\nChildren:\n%s" % (self.gTitle(), self.gDesc(), self.gXMLContent(), (';\n'.join(str(child) for child in self.children) if self.children else None))

    def __repr__(self):
        return self.__str__()

    def setSectionIndex(self, i, recursive = True):
        self.ref = i

        if recursive and self.hasChildren():
            for n_i, child in enumerate(self.children):
                child.setSectionIndex(n_i)

    def setSectionFullRef(self, i, recursive = True):
        self.fullref = i
        if recursive and self.hasChildren():
            for n_i, child in enumerate(self.children):
                child.setSectionFullRef("%s.%s" % (i, n_i))

    def getPathByTitle(self, name):
        if self.hasTitle():
            if self.tTitle().replace(' ', '').lower() == name:
                return ''

            if self.hasChildren():
                for n_i, child in enumerate(self.children):
                    result = child.getPathByTitle(name)

                    if result is not None:
                        return '%s.%s' % (n_i, result)

    def toHTML(self):
        header = generatePathHeader(self.fullref, self.title)
        cntf = childC = None

        if self.hasDesc():
            cntf = contentToHTML(self.desc, self.parent)
        elif self.hasContent():
            cntf = contentToHTML(self.content, self.parent)

        if self.hasChildren():
            childC = '\n\n'.join(child.toHTML() for child in self.children)

        return header + (cntf if cntf else '') + (childC if childC else '')

    def generateSectionTree(self):
        if self.hasChildren():
            header = "<b>%s</b>:\n%s\n<ul>"
            footer = "</ul>"
            return header % (self.fullref, self.title.text) + "\n".join("""<li class="t-elem" udderref="%s">%s</li>""" % (hashID(s.fullref), s.generateSectionTree()) for s in self.children) + footer
        else:
            return '%s' % ("<b>%s</b>: %s" % (self.fullref, self.title.text))



def extractTitleNode(node):
    index = 0
    title_result = None

    for title in node.findall("title"):
        if index > 0:
            print "Warning: more than one title found"

        title_result = title
        index += 1

    return title_result

def extractDescNode(node):
    index = 0
    desc_result = None

    for desc in node.findall("desc"):
        if index > 0:
            print "Warning: more than one description found"

        desc_result = desc
        index += 1

    for desc in node.findall("description"):
        if index > 0:
            print "Warning: more than one description found"

        desc_result = desc
        index += 1

    return desc_result

def extractContentNode(node):
    index = 0
    content_result = None

    for content in node.findall("content"):
        if index > 0:
            print "Warning: more than one content element found"

        content_result = content
        index += 1

    return content_result

def XMLSectiontoSection(node, article):
    children_list = []

    for s in node.findall("section"):
        children_list.append(XMLSectiontoSection(s, article))

    l = Section(extractDescNode(node), extractTitleNode(node), extractContentNode(node), children_list if children_list else None)
    l.setParent(article)

    return l

def writeHeaders(file_obj, title = "Article", sect_tree = ""):
    file_obj.write(document_header % (title, sect_tree))

def writeEndings(file_obj):
    file_obj.write(document_ending)

class Article:
    def __init__(self, root_node):
        self.top_sections = []
        self.section_dict = {}

        self.root_node = root_node
        self.header_scripts = []
        self.footer_scripts = []

        self.opts = {}

    def parseSections(self):
        sectionlist = self.root_node.findall("section")
        self.top_sections = [XMLSectiontoSection(s, self) for s in sectionlist]

    def numberSections(self):
        for i, section in enumerate(self.top_sections):
            section.setSectionIndex(i, True)
            section.setSectionFullRef(str(i), True)

    def getPathByTitle(self, name):
        name = name.replace(' ', '').lower()

        for i, section in enumerate(self.top_sections):
            result = section.getPathByTitle(name)
            if result:
                return '%s.%s' % (i, result.rstrip('.'))

    def getHashByTitle(self, name):
        return hashLoc(self.getPathByTitle(name))

    def generateSectionTree(self):
        header = """<ul class="tree">"""
        footer = """</ul> <!-- end tree -->"""

        contentf = '\n'.join("""<li class="t-elem" udderref="%s">%s</li>""" % (hashID(str(i)), s.generateSectionTree()) for i,s in enumerate(self.top_sections))

        self.section_tree = header + contentf + footer

    def flatten(self):
        for section in self.top_sections:
            yield section.toHTML()

    def writeContents(self, file_obj):
        [file_obj.write(line + '\n') for line in self.flatten()]

    def getContents(self):
        return ''.join(line + '\n' for line in self.flatten())

    def writeHeaderScripts(self, file_obj):
        file_obj.write("\n<!-- Begin header scripts -->\n<script>%s</script>\n<!-- End header scripts -->" % (';\n'.join(self.header_scripts)))

    def writeFooterScripts(self, file_obj):
        file_obj.write("\n<!-- Begin footer scripts -->\n<script>%s</script>\n<!-- End footer scripts -->\n" % (';\n'.join(self.footer_scripts)))

    def addHeaderScript(self, script):
        self.header_scripts.append(script)

    def addFooterScript(self, script):
        self.footer_scripts.append(script)

    def writeTo(self, filef):
        with codecs.open(filef, 'w', "utf-8") as file_obj:
            writeHeaders(file_obj, "C++ Article", self.section_tree)

            all_content = self.getContents()

            self.writeHeaderScripts(file_obj)
            file_obj.write(all_content)
            self.writeFooterScripts(file_obj)

            writeEndings(file_obj)

    def loadVocab(self, vocab_file):
        self.vocab = {}

        i = 0
        with open(vocab_file, 'r') as filef:
            for line in filef:
                i += 1

                if line.isspace():
                    continue

                sindex = line.find(':')

                if sindex == -1:
                    raise IndexError('Vocab parsing error at line %s: No separator found' % i)

                word = line[:sindex].rstrip().lower().replace(' ','')
                definition = line[sindex + 1: ].lstrip()

                self.vocab[word] = definition

    def findVocab(self, search):
        query = search.lower().replace(' ', '')

        if query in self.vocab:
            return self.vocab[query]
        else:
            raise KeyError("Definition for " + search + " does not exist!")

    def root(self):
        return self.root_node

    def __str__(self):
        return XMLtostr(self.root_node)

    def __repr__(self):
        return self.__str__()

if __name__ == "__main__":
    file_name = "cpp_article.xml"
    vocab_name = "vocab.txt"
    output_name = "output.html"

    article_reader = ArticleReader(file_name)

    print "Reading and parsing XML..."
    article_reader.readXML()
    print "Parsed XML."

    article = Article(article_reader.root_node)

    article.loadVocab(vocab_name)
    article.parseSections()
    article.numberSections()
    article.generateSectionTree()

    article.writeTo(output_name)
